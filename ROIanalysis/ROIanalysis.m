function ROIanalysis(ImageFile, ExperimentFile, ROIFile, varargin)
% ROIANALYSIS Circle ROIs in imaging data as well as and/or create
% presentable data.
%
%   ROIANALYSIS(ImageFile), for a string or cell array of strings
%   specifying the filenames of the image file(s), the program will
%   automatically open the file(s). (Supports ScanImage or Scanbox
%   generated images)
%
%   ROIANALYSIS(ImageFile,ExperimentFile), for a string specifying the
%   filename of an Experiment File, the program will automatically load in
%   the file. (Experiment File generated by 'CaImaging' only)
%
%   ROIANALYSIS(ImageFile,ExperimentFile,ROIFile), for a string specifying
%   the filename of a ROI File, the program will automatically load in the
%   file. (ROI File generated by 'ROIanalysis' only)
%
%   HotKeys:
%       Base State
%           Add ROI         - 'r'
%           Edit ROI        - 'e'
%           Next Frame      - 'd' or right arrow
%           Last Frame      - 'a' or left arrow
%           Play/Pause      - spacebar or 'enter'
%       ROI being edited
%           Save ROI        - spacebar, 'enter', or 'r'
%           Delete ROI      - 'backspace', 'delete', or 'e'
%           Move up         - 'w' or up arrow
%           Move down       - 's' or down arrow
%           Move right      - 'd' or right arrow
%           Move left       - 'a' or left arrow
%           Move deeper     - '>'
%           Move shallower  - '<'


%% Parse input arguments
LoadType = 'Direct';
Frames = [1 inf];
Channels = [1 inf];

index = 1;
while index<=length(varargin)
    try
        switch varargin{index}
            case 'Config'
                configFile = varargin{index+1};
                index = index + 2;
            case 'LoadType'
                LoadType = varargin{index+1};
                index = index + 2;
            case 'Frames'
                Frames = varargin{index+1};
                index = index + 2;
            case 'Channels'
                Channels = varargin{index+1};
                index = index + 2;
           case {'Depths', 'depths'}
                Depths = varargin{index+1};
                index = index + 2;
            otherwise
                warning('Argument ''%s'' not recognized',varargin{index});
                index = index + 1;
        end
    catch
        warning('Argument %d not recognized',index);
        index = index + 1;
    end
end

if exist('ImageFile', 'var') && ~isempty(ImageFile)
    if ~iscellstr(ImageFile)
        ImageFile = {ImageFile};
    end
    gd.state.dataAvailable = true;
else
    gd.state.dataAvailable = false;
end

if exist('ExperimentFile', 'var') && ~isempty(ExperimentFile)
    gd.state.experimentAvailable = true;
else
    gd.state.experimentAvailable = false;
end

if exist('ROIFile', 'var') && ~isempty(ROIFile)
    gd.state.roisAvailable = true;
else
    gd.state.roisAvailable = false;
end

if ~exist('configFile', 'var')
    gd.config = initConfig;
else
    temp = load(configFile, 'config', '-mat');
    gd.config = temp.config;
end

%% Configure Default Display Settings
locations = FrankenScopeRigFile();
gd.Internal.directory = locations.ROIanalysisDefaultPath ;
gd.Internal.Settings.ROITextSize = 20;
gd.Internal.Settings.ROILineWidth = 2;
gd.Internal.Settings.StimMarkSize = 20;
gd.Internal.Settings.StimMarkColor = [1,0,0];
gd.Internal.Settings.RunSpeedSize = 20;
gd.Internal.Settings.RunSpeedColor = [1,1,1];
gd.Internal.Settings.PlayFrameRate = 15.5;
gd.Internal.Settings.NeuropilDistance = 5;
gd.Holo.centerStack = 1;
%% Configure Image settings
gd.Internal.Images.defaultComputations = {'Raw'};

%% Configure ROI settings
gd.Internal.ROIs.n = 0;
gd.ROIs.filename = [];
gd.ROIs.offset = [0,0,0];
gd.ROIs.rois = [];
gd.Internal.ROIs.tagIndex = 0;
gd.Internal.ROIs.current = false;
gd.Internal.ROIs.nlabels = numel(gd.config.ROIs.labels);
gd.Internal.ROIs.labels = [gd.config.ROIs.labels, 'other', 'multiple', 'none'];
gd.Internal.ROIs.colors.labels = [gd.config.ROIs.colors.labels, 'blue', 'white', 'magenta'];
gd.Internal.ROIs.colors.random = ...
    [1,0,1;...
    0,1,1;...
    1,0,0;...
    0,1,0;...
    0,0,1;...
    1,1,1]; % colors to display ROIs in
gd.Internal.ROIs.nColors = size(gd.Internal.ROIs.colors.random, 1);

%% Create & Populate Figure

% Create figure
gd.fig = figure(...
    'NumberTitle',          'off',...
    'Name',                 'ROIanalysis',...
    'ToolBar',              'none',...
    'Units',                'pixels',...
    'Position',             gd.config.Figure.pos,...
    'KeyPressFcn',          @(hObject,eventdata)KeyPressCallback(hObject,eventdata,guidata(hObject)));

% IMAGE LOADING
% panel
gd.LoadImages.panel = uipanel(...
    'Title',                'Image File',...
    'Parent',               gd.fig,...
    'Units',                'Normalized',...
    'Position',             [0, .7, .15, .3]);
% load button
gd.LoadImages.load = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Load Images',...
    'Parent',               gd.LoadImages.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.9,.49,.1],...
    'Callback',             @(hObject,eventdata)LoadImages(hObject,eventdata,guidata(hObject)),...
    'BackgroundColor',      [.3,.3,.3],...
    'ForegroundColor',      [1,1,1]);
% load type
gd.LoadImages.type = uicontrol(...
    'Style',                'popupmenu',...
    'String',               {'Direct','MemMap'},...
    'Parent',               gd.LoadImages.panel,...
    'Units',                'normalized',...
    'Position',             [.5,.9,.49,.1]);
% frames to load
gd.LoadImages.frames = uicontrol(...
    'Style',                'edit',...
    'String',               'Frames: all',...
    'Parent',               gd.LoadImages.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.8,.49,.1]);
% channels to load
gd.LoadImages.channels = uicontrol(...
    'Style',                'edit',...
    'String',               'Channels: all',...
    'Parent',               gd.LoadImages.panel,...
    'Units',                'normalized',...
    'Position',             [.5,.8,.49,.1]);
% information listbox
gd.LoadImages.info = uicontrol(...
    'Style',                'listbox',...
    'String',               [],...
    'Parent',               gd.LoadImages.panel,...
    'Units',                'normalized',...
    'Position',             [.01,0,.98,.78]);

% EXPERIMENT LOADING
% panel
gd.LoadExperiment.panel = uipanel(...
    'Title',                'Experiment File',...
    'Parent',               gd.fig,...
    'Units',                'Normalized',...
    'Position',             [0, 0, .15, .3]);
% load button
gd.LoadExperiment.load = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Load Experiment',...
    'Parent',               gd.LoadExperiment.panel,...
    'Units',                'normalized',...
    'Position',             [.1,.9,.8,.1],...
    'Callback',             @(hObject,eventdata)LoadExperiment(hObject,eventdata,guidata(hObject)),...
    'BackgroundColor',      [.3,.3,.3],...
    'ForegroundColor',      [1,1,1]);
% information listbox
gd.LoadExperiment.info = uicontrol(...
    'Style',                'listbox',...
    'String',               [],...
    'Parent',               gd.LoadExperiment.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.3,.98,.58],...
    'Callback',             @(hObject,eventdata)ExperimentInfo(hObject,eventdata,guidata(hObject)));
% frame organization pop up menu (temporal, trial type)
gd.LoadExperiment.display = uicontrol(...
    'Style',                'popupmenu',...
    'String',               {'temporal', 'stimulus'},...
    'Parent',               gd.LoadExperiment.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.2,.48,.1],...
    'Callback',             @(hObject,eventdata)DisplayTimeline(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off');
% correct motion
gd.LoadExperiment.MC = uicontrol(...
    'Style',                'checkbox',...
    'String',               'Apply Motion Correction',...
    'Parent',               gd.LoadExperiment.panel,...
    'Units',                'normalized',...
    'Position',             [.01,0,.48,.2],...
    'Enable',               'off',...
    'Callback',             @(hObject,eventdata)plotmainaxes([],[],guidata(hObject)));
% show stimulus mark
gd.LoadExperiment.showStimMark = uicontrol(...
    'Style',                'checkbox',...
    'String',               'Stimulus Mark',...
    'Parent',               gd.LoadExperiment.panel,...
    'Units',                'normalized',...
    'Position',             [.5,.15,.49,.1],...
    'Enable',               'off',...
    'Callback',             @(hObject,eventdata)replotaxes(hObject,eventdata,guidata(hObject)));
% show running speed
gd.LoadExperiment.showRunSpeed = uicontrol(...
    'Style',                'checkbox',...
    'String',               'Running Speed',...
    'Parent',               gd.LoadExperiment.panel,...
    'Units',                'normalized',...
    'Position',             [.5,.05,.49,.1],...
    'Enable',               'off',...
    'Callback',             @(hObject,eventdata)replotaxes(hObject,eventdata,guidata(hObject)));

% DATA SELECTION
% panel
gd.DataSelection.panel = uipanel(...
    'Title',                'Display',...
    'Parent',               gd.fig,...
    'Units',                'Normalized',...
    'Position',             [0, .3, .15, .4]);
% channel selection table
gd.DataSelection.channel = uitable(...
    'Parent',               gd.DataSelection.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.75,.98,.25],...
    'ColumnName',           {'View','Color'},...
    'ColumnEditable',       [true, false],...
    'ColumnFormat',         {'logical','char'},...
    'ColumnWidth',          {50,50,70},...
    'CellEditCallback',     @(hObject,eventdata)DataSelection(hObject,eventdata,guidata(hObject)));
% lower limit slider
gd.DataSelection.climMin = uicontrol(...
    'Style',                'slider',...
    'Parent',               gd.DataSelection.panel,...
    'Units',                'normalized',...
    'Position',             [.2,.625,.78,.125],...
    'Callback',             @(hObject,eventdata)ClimMinimum(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off');
gd.DataSelection.climMinText = uicontrol(...
    'Style',                'text',...
    'String',               '',...
    'Parent',               gd.DataSelection.panel,...
    'Units',                'normalized',...
    'Position',             [0,.625,.2,.125],...
    'FontSize',             10);
% upper limit slider
gd.DataSelection.climMax = uicontrol(...
    'Style',                'slider',...
    'Parent',               gd.DataSelection.panel,...
    'Units',                'normalized',...
    'Position',             [.2,.5,.78,.125],...
    'Callback',             @(hObject,eventdata)ClimMaximum(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off');
gd.DataSelection.climMaxText = uicontrol(...
    'Style',                'text',...
    'String',               '',...
    'Parent',               gd.DataSelection.panel,...
    'Units',                'normalized',...
    'Position',             [0,.5,.2,.125],...
    'FontSize',             10);
% computation selection listbox
gd.DataSelection.computation = uicontrol(...
    'Style',                'listbox',...
    'String',               [],...
    'Parent',               gd.DataSelection.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.1,.98,.4],...
    'Callback',             @(hObject,eventdata)ViewSelection(hObject,eventdata,guidata(hObject)));
% built-in computations
gd.DataSelection.computationAvail = uicontrol(...
    'Style',                'popupmenu',...
    'String',               {'Average' 'DFF' 'ComputeAverageMovs'},...
    'Parent',               gd.DataSelection.panel,...
    'Units',                'normalized',...
    'Position',             [.01,0,.69,.1])
% built-in compute computation
gd.DataSelection.computationCompute = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Compute',...
    'Parent',               gd.DataSelection.panel,...
    'Units',                'normalized',...
    'Position',             [.7,0,.29,.1],...
    'Callback',             @(hObject,eventdata)ComputeComputation(hObject,eventdata,guidata(hObject)));

% DATA VIEW
% panel
gd.View.panel = uipanel(...
    'Title',                'Display',...
    'Parent',               gd.fig,...
    'Units',                'Normalized',...
    'Position',             [.15, 0, .6, 1]);
% axes
gd.View.axes = axes(...
    'Parent',               gd.View.panel,...
    'Units',                'normalized',...
    'Position',             [0,0,1,.9]);
axis off;
% frame selection slider
gd.View.frameSlider = uicontrol(...
    'Style',                'slider',...
    'Parent',               gd.View.panel,...
    'Units',                'normalized',...
    'Position',             [0,.925,1,.025],...
    'Enable',               'off',...
    'Callback',             @(hObject,eventdata)FrameSelection(hObject,eventdata,guidata(hObject)));
% depth selection slider
gd.View.depthSlider = uicontrol(...
    'Style',                'slider',...
    'Parent',               gd.View.panel,...
    'Units',                'normalized',...
    'Position',             [0,.9,1,.025],...
    'Enable',               'off',...
    'Callback',             @(hObject,eventdata)DepthSelection(hObject,eventdata,guidata(hObject)));
% frame count
gd.View.currentFrame = uicontrol(...
    'Style',                'text',...
    'String',               '',...
    'Parent',               gd.View.panel,...
    'Units',                'normalized',...
    'Position',             [.2,.96,.2,.04],...
    'FontSize',             20);
% depth count
gd.View.currentDepth = uicontrol(...
    'Style',                'text',...
    'String',               '',...
    'Parent',               gd.View.panel,...
    'Units',                'normalized',...
    'Position',             [.4,.96,.2,.04],...
    'FontSize',             20);
% play button
gd.View.playPause = uicontrol(...
    'Style',                'togglebutton',...
    'String',               'Play',...
    'Parent',               gd.View.panel,...
    'Units',                'normalized',...
    'Position',             [0,.96,.2,.04],...
    'Callback',             @(hObject,eventdata)PlayPause(hObject,eventdata,guidata(hObject)));
% save image button
gd.View.saveImage = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Save Frame',...
    'Parent',               gd.View.panel,...
    'Units',                'normalized',...
    'Position',             [.8,.975,.2,.024],...
    'Callback',             @(hObject,eventdata)SaveImage(hObject,eventdata,guidata(hObject)),...
    'BackgroundColor',      [.8,.8,.8]);
% save video button (save from current or beggining to input value)
gd.View.saveVideo = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Save Video',...
    'Parent',               gd.View.panel,...
    'Units',                'normalized',...
    'Position',             [.8,.951,.2,.024],...
    'Callback',             @(hObject,eventdata)SaveVideo(hObject,eventdata,guidata(hObject)),...
    'BackgroundColor',      [.8,.8,.8]);

% ROI MANAGEMENT
% panel
gd.ROI.panel = uipanel(...
    'Title',                'ROIs',...
    'Parent',               gd.fig,...
    'Units',                'Normalized',...
    'Position',             [.75, .05, .25, .95]);
% load button
gd.ROI.load = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Load ROIs',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.95,.2,.05],...
    'Callback',             @(hObject,eventdata)LoadROIs(hObject,eventdata,guidata(hObject)),...
    'BackgroundColor',      [.3,.3,.3],...
    'ForegroundColor',      [1,1,1]);
% save button
gd.ROI.saveFile = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Save ROIs',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.9,.2,.05],...
    'Callback',             @(hObject,eventdata)SaveROIs(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off',...
    'BackgroundColor',      [.8,.8,.8]);
% show ROIs toggle
gd.ROI.show = uicontrol(...
    'Style',                'checkbox',...
    'String',               'Show ROIs',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.8,.25,.025],...
    'Value',                true,...
    'ToolTipString',        'Show ROIs: ''v''',...
    'Callback',             @(hObject,eventdata)replotaxes(hObject,eventdata,guidata(hObject)));
% show ID numbers toggle
gd.ROI.showIDs = uicontrol(...
    'Style',                'checkbox',...
    'String',               'Show ID #s',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.775,.25,.025],...
    'Value',                true,...
    'Callback',             @(hObject,eventdata)replotaxes(hObject,eventdata,guidata(hObject)));
% show on depth toggle
gd.ROI.showDepth = uicontrol(...
    'Style',                'checkbox',...
    'String',               'Specific depth',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.26,.8,.25,.025],...
    'Value',                true,...
    'Callback',             @(hObject,eventdata)replotaxes(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off');
% show ID numbers toggle
gd.ROI.editAll = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Edit All',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.8625,.2,.025],...
    'Value',                false,...
    'Callback',             @(hObject,eventdata)EditAllROIs(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off',...
    'BackgroundColor',      [1,1,.7]);
% delete all button
gd.ROI.deleteAll = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Delete All',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.8375,.2,.025],...
    'Callback',             @(hObject,eventdata)DeleteAllROIs(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off',...
    'BackgroundColor',      [1,.7,.7]);
% color popupmenu
gd.ROI.color = uicontrol(...
    'Style',                'popupmenu',...
    'String',               {'random', 'labels'},...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.59,.8,.2,.025],...
    'Callback',             @(hObject,eventdata)replotaxes(hObject,eventdata,guidata(hObject)));
% type of ROI pop up menu
gd.ROI.type = uicontrol(...
    'Style',                'popupmenu',...
    'String',               {'ellipse', 'polygon'},...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.75,.2,.025]); %[.01,.775,.25,.025]
% add ROI button
gd.ROI.add = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Add',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.7,.2,.05],...
    'Callback',             @(hObject,eventdata)AddROI(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off',...
    'BackgroundColor',      [.7,.7,1],...
    'ToolTipString',        'Add ROI: ''r''');
% edit ROI button
gd.ROI.edit = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Edit',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.65,.2,.05],...
    'Callback',             @(hObject,eventdata)EditROI(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off',...
    'BackgroundColor',      [1,1,.7],...
    'ToolTipString',        'Edit ROI: ''e''');
% info listbox
gd.ROI.info = uicontrol(...
    'Style',                'listbox',...
    'String',               [],...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.21,.55,.5,.2]);
% add label button
gd.ROI.addLabel = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Add Label',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.79,.8,.2,.025],...
    'Callback',             @(hObject,eventdata)AddROILabel(hObject,eventdata,guidata(hObject)));
% labels table
gd.ROI.labels = uitable(...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.23,.825,.76,.175],...
    'RowName',              [],...
    'ColumnWidth',          {70,70,50,50,40},...
    'ColumnName',           {'Label','Color','Up','Down','Delete'},...
    'ColumnEditable',       [true, true, true, true, true],...
    'ColumnFormat',         {'char','char','logical','logical','logical'},...
    'CellEditCallback',     @(hObject,eventdata)EditLabelsTable(hObject,eventdata,guidata(hObject)));
data = cell(numel(gd.Internal.ROIs.labels),3);
data(:,1) = gd.Internal.ROIs.labels;
data(:,2) = gd.Internal.ROIs.colors.labels;
data(:,3:5) = {false};
set(gd.ROI.labels, 'Data', data);
% current: save
gd.ROI.save = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Save',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.6,.2,.05],...
    'Callback',             @(hObject,eventdata)SaveROI(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off',...
    'BackgroundColor',      [.7,1,.7],...
    'ToolTipString',        'Save ROI: ''space'', ''r'', or ''enter''');
% current: delete
gd.ROI.delete = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Delete',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.55,.2,.05],...
    'Callback',             @(hObject,eventdata)DeleteROI(hObject,eventdata,guidata(hObject)),...
    'Enable',               'off',...
    'BackgroundColor',      [1,.7,.7],...
    'ToolTipString',        'Delete ROI: ''backspace'' or ''delete''');
% current: labels
gd.ROI.currentLabels = uicontrol(...
    'Style',                'listbox',...
    'String',               '',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.71,.55,.28,.2],...
    'Callback',             @(hObject,eventdata)ROIcurrentLabels(hObject,eventdata,guidata(hObject)),...
    'KeyPressFcn',          @(hObject,eventdata)ROIcurrentLabelKeyPress(hObject,eventdata,guidata(hObject)));
% current: tag
gd.ROI.currentTag = uicontrol(...
    'Style',                'edit',...
    'String',               'tag',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.21,.75,.78,.025],...
    'Callback',             @(hObject,eventdata)ROIcurrentTag(hObject,eventdata,guidata(hObject)));
% tabs
% gd.ROI.tabgroup = uitabgroup(...
%     'Parent',               gd.ROI.panel,...
%     'Units',                'normalized',...
%     'Position',             [0,0,1,.7]);
% current ROI tab
% gd.ROI.currentTab = uitab(...
%     'Title',                'Current ROI',...
%     'Parent',               gd.ROI.tabgroup);
% current: activity axes
% h.ROI.currentInfo = axes(...
%     'Parent',               h.ROI.currentTab,...
%     'Units',                'normalized',...
%     'Position',             [.01,.7,.98,.2]);
% xray tab
% gd.ROI.xrayTab = uitab(...
%     'Title',                'X-Ray',...
%     'Parent',               gd.ROI.tabgroup);
% xray: axes

% EXPORT
gd.ExportData.panel = uipanel(...
    'Title',                'Export data',...
    'Parent',               gd.fig,...
    'Units',                'Normalized',...
    'Position',             [.75, 0, .25, .05]);
% export button
gd.ExportData.export = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Export',...
    'Parent',               gd.ExportData.panel,...
    'Units',                'normalized',...
    'Position',             [.79,0.1,.2,.98],...
    'Callback',             @(hObject,eventdata)ExportData(hObject,eventdata,guidata(hObject)),...
    'BackgroundColor',      [.8,.8,.8]);
% selection popup menu
gd.ExportData.selection = uicontrol(...
    'Style',                'popupmenu',...
    'String',               {},...
    'Parent',               gd.ExportData.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.1,.78,.98]);
% load button
gd.Holo.send = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Send to HoloStim',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.4,.5,.12],...
    'Callback',             @(hObject,eventdata)sendToHolostim(hObject,eventdata,guidata(hObject)),...
    'BackgroundColor',      [.3,.3,.3],...
    'ForegroundColor',      [1,1,1]);
% load button
gd.Holo.send = uicontrol(...
    'Style',                'pushbutton',...
    'String',               'Exract ROIs',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.03,.2,.4,.12],...
    'Callback',             @(hObject,eventdata)ExtractROIs(hObject,eventdata,guidata(hObject)),...
    'BackgroundColor',      [.3,.3,.3],...
    'ForegroundColor',      [1,1,1]);

% removed because we really don't use centered stack anymore
% gd.LoadExperiment.showRunSpeed = uicontrol(...
%     'Style',                'checkbox',...
%     'String',               'Centered Stack?',...
%     'Parent',               gd.ROI.panel,...
%     'Units',                'normalized',...
%     'Position',             [.01,.3,.5,.1],...
%     'Enable',               'on',...
%     'Callback',             @(hObject,eventdata)centerStack(hObject,eventdata,guidata(hObject)));


gd.Holo.displayTarget = uicontrol(...
    'Style',                'checkbox',...
    'String',               'Display Targetable Area',...
    'Parent',               gd.ROI.panel,...
    'Units',                'normalized',...
    'Position',             [.01,.3,.5,.1],...
    'Enable',               'on',...
    'Callback',             @(hObject,eventdata)dispTargetArea(hObject,eventdata,guidata(hObject)));



%% Context Menus
% Right click ROI
gd.ROIcontextmenu.handle = uicontextmenu(...
    'Callback',             @(hObject,eventdata)ROIcontextmenu(hObject,eventdata,guidata(hObject)));
for l = 1:numel(gd.Internal.ROIs.labels)
    if ~strcmp(gd.Internal.ROIs.labels(l), {'other', 'multiple', 'none'})
        gd.ROIcontextmenu.menus(l).label = gd.Internal.ROIs.labels{l};
        gd.ROIcontextmenu.menus(l).handle = uimenu(...
            'Parent',               gd.ROIcontextmenu.handle,...
            'Label',                gd.ROIcontextmenu.menus(l).label,...
            'Tag',                  num2str(l),...
            'Callback',             @(hObject,eventdata)ROIlabel(hObject,eventdata,guidata(hObject)));
    end
end
gd.ROIcontextmenu.other = uimenu(...
    'Parent',               gd.ROIcontextmenu.handle,...
    'Label',                'other',...
    'Callback',             @(hObject,eventdata)ROIlabelOther(hObject,eventdata,guidata(hObject)));
gd.ROIcontextmenu.color = uimenu(...
    'Parent',               gd.ROIcontextmenu.handle,...
    'Label',                'Change Color',...
    'Separator',            'on',...
    'Callback',             @(hObject,eventdata)ROIchangeColor(hObject,eventdata,guidata(hObject)));
% Right click text
gd.Textcontextmenu.handle = uicontextmenu(...
    'Callback',             @(hObject,eventdata)Textcontextmenu(hObject,eventdata,guidata(hObject)));
gd.Textcontextmenu.size = uimenu(...
    'Parent',               gd.Textcontextmenu.handle,...
    'Label',                'Change Font Size',...
    'Callback',             @(hObject,eventdata)Textchangesize(hObject,eventdata,guidata(hObject)));
gd.Textcontextmenu.color = uimenu(...
    'Parent',               gd.Textcontextmenu.handle,...
    'Label',                'Change Color',...
    'Callback',             @(hObject,eventdata)Textchangecolor(hObject,eventdata,guidata(hObject)));

%% Save guidata
guidata(gd.fig, gd);

%% Load passed in arguments
if gd.state.dataAvailable
    LoadImages(gd.LoadImages.load, {ImageFile, LoadType, Frames, Channels}, guidata(gd.fig));
end
if gd.state.experimentAvailable
    LoadExperiment(gd.LoadExperiment.load, ExperimentFile, guidata(gd.fig));
end
if gd.state.roisAvailable
    LoadROIs(gd.ROI.load, ROIFile, guidata(gd.fig));
end



%% KEYPRESS CALLBACKS
function KeyPressCallback(hObject,eventData,gd)

% Pre Data Loaded
if gd.state.dataAvailable==false %nothing loaded
    switch eventData.Key
        case 'l' %load Imgs
            LoadImages(gd.LoadImages.load, [], gd);
    end

else % Post Data Loaded
    switch gd.state.UIstate
        
        % ROI not being edited
        case 'ready' %base state
            if ~isempty(eventData.Modifier)
                switch eventData.Modifier{1}
                    case 'shift'
                        step = 10;
                end
            else
                step = 1;
            end
            switch eventData.Key
                case {'uparrow','w'} %move up one depth
                    nextimg = gd.state.currentDepth + step;
                    if nextimg > get(gd.View.depthSlider,'Max');
                        nextimg = 1;
                    end
                    set(gd.View.depthSlider,'value',nextimg);
                    plotmainaxes([],nextimg,gd);
                case {'downarrow','s'} %move down one depth
                    nextimg = gd.state.currentDepth - step;
                    if nextimg < get(gd.View.depthSlider,'Min');
                        nextimg = get(gd.View.depthSlider, 'Max');
                    end
                    set(gd.View.depthSlider,'value',nextimg);
                    plotmainaxes([],nextimg,gd);
                case {'rightarrow','d'} %move right one frame
                    currentimg = round(get(gd.View.frameSlider,'Value'));
                    nextimg = currentimg + step;
                    if nextimg > get(gd.View.frameSlider,'Max');
                        nextimg = 1;
                    end
                    set(gd.View.frameSlider,'value',nextimg);
                    plotmainaxes(nextimg,[],gd);
                case {'leftarrow','a'} %move left one frame
                    currentimg = round(get(gd.View.frameSlider,'Value'));
                    nextimg = currentimg - step;
                    if nextimg < get(gd.View.frameSlider,'Min');
                        nextimg = get(gd.View.frameSlider,'Max');
                    end
                    set(gd.View.frameSlider,'value',nextimg);
                    plotmainaxes(nextimg,[],gd);
                case {'return','space'} %play/pause movie
                    set(gd.View.playPause,'Value',abs(get(gd.View.playPause,'Value')-1)); %toggle button
                    PlayPause(gd.View.playPause, [], gd);
                case 'r' %add ROI
                    AddROI(gd.ROI.add, [], gd);
                case 'e' %edit ROI
                    if gd.Internal.ROIs.n > 0 %only if ROIs exist
                        EditROI(gd.ROI.edit, [], gd);
                    end
                case 'v'
                    if gd.Internal.ROIs.n > 0 %only if ROIs exist
                        set(gd.ROI.show, 'Value', abs(get(gd.ROI.show, 'Value')-1));
                        plotmainaxes([],[],gd);
                    end
            end %switch E.Key, state='ready'
            
        case 'ROIedit' %ROI being edited or added
            editIndex = find([gd.ROIs.rois(:).beingEdited]);
            editAll = all([gd.ROIs.rois(:).beingEdited]) && numel(gd.ROIs.rois)>1;
            if ~isempty(eventData.Modifier)
                step = 10;
            else
                step = 1;
            end
            switch eventData.Key
                case {'uparrow','w'} %translate ROI up
                    for rindex = editIndex
                        switch gd.ROIs.rois(rindex).type % save ROI
                            case 'ellipse'
                                position = getPosition(gd.ROIs.rois(rindex).handle);
                                if position(2) >= step+.5 %constrain to image boundary
                                    position(2) = position(2) - step; %translate up
                                    setPosition(gd.ROIs.rois(rindex).handle, position);
                                    gd.ROIs.rois(rindex).position = position;
                                    gd.ROIs.rois(rindex).vertices = getVertices(gd.ROIs.rois(rindex).handle);
                                end
                            case 'polygon'
                                vertices = getPosition(gd.ROIs.rois(rindex).handle);
                                if vertices(:,2) >= step + .5; %constrain to image boundary
                                    vertices(:,2) = vertices(:,2) - step; %translate up
                                    setPosition(gd.ROIs.rois(rindex).handle, vertices);
                                    gd.ROIs.rois(rindex).vertices = [vertices;vertices(1,:)];
                                end
                        end
                    end
                    if editAll
                        gd.ROIs.offset(1) = gd.ROIs.offset(1) + step;
                    end
                    guidata(hObject, gd);
                case {'downarrow','s'} %translate ROI down
                    for rindex = editIndex
                        switch gd.ROIs.rois(rindex).type % save ROI
                            case 'ellipse'
                                position = getPosition(gd.ROIs.rois(rindex).handle);
                                Y = get(gca,'YLim');
                                if position(2)+position(4) <= Y(2)-step; %constrain to image boundary
                                    position(2) = position(2) + step; %translate down
                                    setPosition(gd.ROIs.rois(rindex).handle,position);
                                    gd.ROIs.rois(rindex).position = position;
                                    gd.ROIs.rois(rindex).vertices = getVertices(gd.ROIs.rois(rindex).handle);
                                end
                            case 'polygon'
                                vertices = getPosition(gd.ROIs.rois(rindex).handle);
                                Y = get(gca,'YLim');
                                if vertices(:,2) <= Y(2)-step; %constrain to image boundary
                                    vertices(:,2) = vertices(:,2) + step; %translate down
                                    setPosition(gd.ROIs.rois(rindex).handle,vertices);
                                    gd.ROIs.rois(rindex).vertices = [vertices;vertices(1,:)];
                                end
                        end
                    end
                    if editAll
                        gd.ROIs.offset(1) = gd.ROIs.offset(1) - step;
                    end
                    guidata(hObject, gd);
                case {'rightarrow','d'} %translate ROI right
                    for rindex = editIndex
                        switch gd.ROIs.rois(rindex).type % save ROI
                            case 'ellipse'
                                position = getPosition(gd.ROIs.rois(rindex).handle);
                                X = get(gca,'XLim');
                                if position(1)+position(3) <= X(2)-step; %constrain to image boundary
                                    position(1) = position(1) + step; %translate right
                                    setPosition(gd.ROIs.rois(rindex).handle,position);
                                    gd.ROIs.rois(rindex).position = position;
                                    gd.ROIs.rois(rindex).vertices = getVertices(gd.ROIs.rois(rindex).handle);
                                end
                            case 'polygon'
                                vertices = getPosition(gd.ROIs.rois(rindex).handle);
                                X = get(gca,'XLim');
                                if vertices(:,1) <= X(2)-step; %constrain to image boundary
                                    vertices(:,1) = vertices(:,1) + step; %translate right
                                    setPosition(gd.ROIs.rois(rindex).handle,vertices);
                                    gd.ROIs.rois(rindex).vertices = [vertices;vertices(1,:)];
                                end
                        end
                    end
                    if editAll
                        gd.ROIs.offset(2) = gd.ROIs.offset(2) + step;
                    end
                    guidata(hObject, gd);
                case {'leftarrow','a'} %translate ROI left
                    for rindex = editIndex
                        switch gd.ROIs.rois(rindex).type % save ROI
                            case 'ellipse'
                                position = getPosition(gd.ROIs.rois(rindex).handle);
                                if position(1) >= step + .5 %constrain to image boundary
                                    position(1) = position(1) - step; %translate left
                                    setPosition(gd.ROIs.rois(rindex).handle,position);
                                    gd.ROIs.rois(rindex).position = position;
                                    gd.ROIs.rois(rindex).vertices = getVertices(gd.ROIs.rois(rindex).handle);
                                end
                            case 'polygon'
                                vertices = getPosition(gd.ROIs.rois(rindex).handle);
                                if vertices(:,1) >= step + .5 %constrain to image boundary
                                    vertices(:,1) = vertices(:,1) - step; %translate left
                                    setPosition(gd.ROIs.rois(rindex).handle,vertices);
                                    gd.ROIs.rois(rindex).vertices = [vertices;vertices(1,:)];
                                end
                        end
                    end
                    if editAll
                        gd.ROIs.offset(2) = gd.ROIs.offset(2) - step;
                    end
                    guidata(hObject, gd);
                case 'comma' %up depth
                    for rindex = editIndex
                        if gd.ROIs.rois(rindex).depth ~= 1
                            gd.ROIs.rois(rindex).depth = gd.ROIs.rois(rindex).depth - 1;
                        end
                    end
                    if editAll
                        gd.ROIs.offset(3) = gd.ROIs.offset(3) - step;
                    end
                    guidata(hObject, gd);
                    if gd.state.currentDepth ~= 1
                        plotmainaxes([],gd.state.currentDepth-1,gd);
                    end
                case 'period' %down depth
                    for rindex = editIndex
                        if gd.ROIs.rois(rindex).depth ~= gd.Images.Depth
                            gd.ROIs.rois(rindex).depth = gd.ROIs.rois(rindex).depth + 1;
                        end
                    end
                    if editAll
                        gd.ROIs.offset(3) = gd.ROIs.offset(3) + step;
                    end
                    guidata(hObject, gd);
                    if gd.state.currentDepth ~= gd.Images.Depth
                        plotmainaxes([],gd.state.currentDepth+1,gd);
                    end
                case 'e' %edit ROI
                    if ~all([gd.ROIs.rois(:).beingEdited]) %only if ROIs exist
                        EditROI(gd.ROI.edit, [], gd);
                    end
                case {'r','return','space'} %save ROI
                    SaveROI(gd.ROI.save, [], gd);
                case {'backspace','delete'} %delete ROI
                    DeleteROI(gd.ROI.delete, [], gd);
            end %switch E.Key, state='ROIedit'
    end %switch h.state.UIstate
end

function ROIcurrentLabelKeyPress(hObject,eventdata,gd)
if any(strcmp(eventdata.Key, {'delete', 'backspace'}))
    gd.ROIs.rois(gd.Internal.ROIs.current).label(get(hObject, 'Value')) = [];
    set(hObject,...
        'String',       gd.ROIs.rois(gd.Internal.ROIs.current).label,...
        'Value',        1);
    guidata(hObject, gd);
    plotmainaxes([],[],gd);
end

%% CLICK CALLBACKS
function ROIClickCallback(hObject,eventdata,gd)
if eventdata.Button == 1
    switch get(hObject, 'Type')
        case 'patch'
            index = get(hObject,'UserData');
            gd.Internal.ROIs.current = index;
            set(gd.ROI.currentLabels, 'String', gd.ROIs.rois(index).label, 'Value', 1);
            set(gd.ROI.currentTag, 'String', gd.ROIs.rois(index).tag);
%             set(gd.ROI.info, 'String', struct2string(gd.ROIs.rois(index),{'pixels','mask','neuropilmask','rawdata','rawneuropil'}), 'Value', 1);
        case 'image'
            gd.Internal.ROIs.current = false;
            set([gd.ROI.currentLabels,gd.ROI.info], 'String', '');
            set(gd.ROI.currentTag, 'String', 'tag');
    end
    guidata(hObject, gd);
    plotmainaxes([],[],gd);
end

%% CONTEXT MENU CALLBACKS

% Right click stimulus mark or running speed
function Textcontextmenu(hObject,eventdata,gd)
% change text size
function Textchangesize(hObject,eventdata,gd)
answer = inputdlg('Font size:', 'Adjust text', 1, {num2str(get(gco, 'FontSize'))});
answer = str2num(answer{1});
set(gco, 'FontSize', answer);
switch get(gco, 'UserData')
    case 'StimMark'
        gd.Internal.Settings.StimMarkSize = answer;
    case 'RunningSpeed'
        gd.Internal.Settings.RunningSpeedSize = answer;
end
guidata(hObject, gd);
% change color
function Textchangecolor(hObject,eventdata,gd)
answer = inputdlg('Color:', 'Adjust text', 1, {num2str(get(gco, 'Color'))});
testnum = str2num(answer{1});
if ~isempty(testnum) && numel(testnum) == 3 % input is 'numeric'
    if any(testnum>1) || any(testnum<0) % validate input
        return
    end
    answer = testnum;
else % 'char'
    if ~any(strcmp(answer{1}, {'y','m','c','r','g','b','w','k','yellow','magenta','cyan','red','green','blue','white','black',''})) % validate input
        return
    end
    answer = answer{1};
end
set(gco, 'Color', answer);
switch get(gco, 'UserData')
    case 'StimMark'
        gd.Internal.Settings.StimMarkColor = answer;
    case 'RunningSpeed'
        gd.Internal.Settings.RunningSpeedColor = answer;
end
guidata(hObject, gd);

% Right click running speed
% change units
% change type (text, shrinking and growing circle, vertical bar)

% Right click ROI
function ROIcontextmenu(hObject,eventdata,gd)
ROIid = get(gco,'UserData'); %index of ROI right-clicked upon
h_uimenus = [gd.ROIcontextmenu.menus(:).handle]; %handles to menu items listed within the context menu
if ~isfield(gd.ROIs.rois, 'label') || isempty(gd.ROIs.rois(ROIid).label)
    set(h_uimenus,'Checked','off') %uncheck all menu items
else
    labels = false(numel(gd.ROIcontextmenu.menus),1);
    for l = 1:numel(gd.ROIs.rois(ROIid).label)
        labels(strcmp(gd.ROIs.rois(ROIid).label(l), {gd.ROIcontextmenu.menus(:).label})) = true;
    end
    set(h_uimenus(labels), 'Checked', 'on')
    set(h_uimenus(~labels), 'Checked', 'off')
end
% change color
function ROIchangeColor(hObject,eventdata,gd)
ROIid = get(gco,'UserData'); %index of ROI right-clicked upon
answer = inputdlg('Enter color (enter nothing for default):', 'Color',1,{num2str(gd.ROIs.rois(ROIid).color)});
if isempty(answer)
    return
end
testnum = str2num(answer{1});
if ~isempty(testnum) && numel(testnum)==3 % input is 'numeric'
    if any(testnum>1) || any(testnum<0) % validate input
        return
    end
    gd.ROIs.rois(ROIid).color = testnum;
else % 'char'
    if ~any(strcmp(answer{1}, {'y','m','c','r','g','b','w','k','yellow','magenta','cyan','red','green','blue','white','black',''})) % validate input
        return
    end
    gd.ROIs.rois(ROIid).color = answer{1};
end
guidata(hObject,gd);
plotmainaxes([],[],gd);
% label
function ROIlabel(hObject,eventdata,gd)
index = get(gco,'UserData'); %index of ROI right-clicked upon
if strcmp(get(hObject,'Checked'),'off') %check PV+ item
    gd.ROIs.rois(index).label = [gd.ROIs.rois(index).label, {get(hObject, 'Label')}];
    set(hObject, 'Checked', 'on');
elseif strcmp(get(hObject,'Checked'),'on')
    l = strcmp(get(hObject,'Label'),gd.ROIs.rois(index).label);
    gd.ROIs.rois(index).label(l) = [];
    set(hObject, 'Checked', 'off');
end
if gd.Internal.ROIs.current == index
    set(gd.ROI.currentLabels, 'String', gd.ROIs.rois(index).label, 'Value', numel(gd.ROIs.rois(index).label));
end
guidata(hObject,gd);
plotmainaxes([],[],gd);
% other label
function ROIlabelOther(hObject,eventdata,gd)
answer = inputdlg('Enter label:', 'Unique Label',1);
if isempty(answer)
    return
end
index = get(gco,'UserData'); %index of ROI right-clicked upon
gd.ROIs.rois(index).label = [gd.ROIs.rois(index).label, answer];
if gd.Internal.ROIs.current == index
    set(gd.ROI.currentLabels, 'String', gd.ROIs.rois(index).label, 'Value', numel(gd.ROIs.rois(index).label));
end
guidata(hObject,gd);
plotmainaxes([],[],gd);

% Right click movie button
% change frame rate


%% INITIALIZATION
function config = initConfig
% Determine screen size
% set(0,'units','pixels')
% pixels = get(0,'screensize');
% Set figure position
config.Figure.pos = [50, 50, 1400, 800];
config.ROIs.labels = {'PV','SST','VIP'};
config.ROIs.colors.labels = {'red','cyan','yellow'};

%% MAIN
function gd = plotmainaxes(frameIndex, depthIndex, gd)

if isempty(frameIndex)
    frameIndex = gd.state.currentFrame;
else
    gd.state.currentFrame = frameIndex;
    set(gd.View.frameSlider, 'Value', frameIndex);
end
set(gd.View.currentFrame, 'String', sprintf('%d / %d', frameIndex, gd.Images.nFrames));

if isempty(depthIndex)
    depthIndex = gd.state.currentDepth;
else
    gd.state.currentDepth = depthIndex;

    set(gd.View.depthSlider, 'Value', depthIndex);
end
set(gd.View.currentDepth, 'String', sprintf('%d / %d', depthIndex, gd.Images.Depth));

Computation = gd.Images.Computations.Names{get(gd.DataSelection.computation, 'Value')};
switch Computation
    
    case 'Raw'
        data = gd.Images.frames(:,:,depthIndex,:,frameIndex);
        if strcmp(gd.Images.type, '.sbx') && any(strcmp(gd.Images.loadType, {'MemMap','memmap'})) % MemMap of sbx images need to be inverted
            data = intmax(gd.Images.info.Precision) - data;
        end
        if get(gd.LoadExperiment.MC, 'Value')
            data = applyMotionCorrection(data, gd.Experiment.MCdata, gd.Images.info, frameIndex, depthIndex);
        end
        
    otherwise
        if ndims(gd.Images.Computations.Data.(gd.Images.Computations.Names{get(gd.DataSelection.computation, 'Value')}))==5
            if frameIndex > size(gd.Images.Computations.Data.(gd.Images.Computations.Names{get(gd.DataSelection.computation, 'Value')}),5)
                frameIndex = size(gd.Images.Computations.Data.(gd.Images.Computations.Names{get(gd.DataSelection.computation, 'Value')}),5);
            end
            data = gd.Images.Computations.Data.(gd.Images.Computations.Names{get(gd.DataSelection.computation, 'Value')})(:,:,depthIndex,:,frameIndex);
        else
            data = gd.Images.Computations.Data.(gd.Images.Computations.Names{get(gd.DataSelection.computation, 'Value')})(:,:,depthIndex,:);
        end
end
if ~isa(data, 'double')
    data = double(data);
end

% Create and format color image
img = zeros(gd.Images.Height, gd.Images.Width, 3);
for c = 1:numel(gd.state.channels)
    if gd.state.channels(c)
        switch gd.state.channelcolors{c}
            case 'Green'
                index = 2;
            case 'Red'
                index = 1;
            case 'Blue'
                index = 3;
        end
    temp = data(:,:,1,c);
    temp = (temp - gd.state.(Computation).clim(c).current(1))./diff(gd.state.(Computation).clim(c).current);
    temp(temp<0) = 0;
    temp(temp>1) = 1;
%     temp = temp./gd.state.(Computation).clim(c).current(2);
%     temp(temp>1) = 1;
%     temp(temp<gd.state.(Computation).clim(c).current(1)/gd.state.(Computation).clim(c).current(2)) = gd.state.(Computation).clim(c).current(1)/gd.state.(Computation).clim(c).current(2);
    img(:,:,index) = temp;
    end
end

% Display Image
axes(gd.View.axes); % display on main axes
% if numel(gd.state.channels) == 1 || all(gd.state.channels == [1, 0])
%     colormap(gd.state.(Computation).colormap(1).current);
%     gd.state.imghandle= imagesc(img); %,gd.state.(Computation).clim(1).current); % display image
% elseif gd.state.channels == [0, 1]
%     colormap(gd.state.(Computation).colormap(2).current);
%     gd.state.imghandle = imagesc(img); %,gd.state.(Computation).clim(2).current); % display image
% elseif gd.state.channels == [1, 1]
gd.state.imghandle = imagesc(img); % display image
%     colormap([gd.state.(Computation).colormap(2).current(:,1),...
%         gd.state.(Computation).colormap(1).current(:,2),...
%         (0:1/(size(gd.state.(Computation).colormap(2).current,1)-1):1)']);
% end
set(gd.state.imghandle, 'ButtonDownFcn', @(hObject,eventdata)ROIClickCallback(hObject,eventdata,guidata(hObject)));
% axis square;
set(gca,'xtick',[],'ytick',[])

% Display ROIs
if gd.Internal.ROIs.n && get(gd.ROI.show, 'Value')
    if any([gd.ROIs.rois(:).beingEdited])
        fcnE = makeConstrainToRectFcn('imellipse',get(gca,'XLim'),get(gca,'YLim'));
        fcnP = makeConstrainToRectFcn('impoly',get(gca,'XLim'),get(gca,'YLim'));
    end
    %     if strcmp(get(gd.viewRoiMask,'Checked'),'on')
    %         % Create ROI Mask
    %         if ~isfield(gd.ROIs, 'totalmask') || isempty(gd.ROIs.totalmask)
    %             gd.ROIs = createROImasks(gd);
    %         end
    %         img = cat(3,zeros(size(gd.ROIs.totalmask)),gd.ROIs.totalmask,gd.ROIs.totalmask); % set mask color
    %         mask = gd.ROIs.totalmask*gd.settings.ROIs.masktransparency; % create mask transparency
    %         hold on
    %         gd.ROIs.maskhandle = image(img); % display mask
    %         hold off
    %         set(gd.ROIs.maskhandle, 'AlphaData', mask); % set transparency
    %         % Create Neuropil Mask
    %         if strcmp(get(gd.toggleNeuropilSubtraction, 'Checked'), 'on')
    %             if ~isfield(gd.ROIs, 'totalneuropilmask') || isempty(gd.ROIs.totalneuropilmask)
    %                 gd.ROIs = createROIneuropilmasks(gd);
    %             end
    %             img = cat(3,gd.ROIs.totalneuropilmask,zeros(size(gd.ROIs.totalneuropilmask)),gd.ROIs.totalneuropilmask); % set mask color
    %             mask = gd.ROIs.totalneuropilmask*gd.settings.ROIs.masktransparency; % create mask transparency
    %             hold on
    %             gd.ROIs.maskhandle = image(img); % display mask
    %             hold off
    %             set(gd.ROIs.maskhandle, 'AlphaData', mask); % set transparency
    %         end
    %     else
    hold all;
    for r = 1:gd.Internal.ROIs.n
        if ~get(gd.ROI.showDepth, 'Value') || depthIndex==gd.ROIs.rois(r).depth
            % Determine if being edited
            if ~gd.ROIs.rois(r).beingEdited
                % Determine Color
                if ~isempty(gd.ROIs.rois(r).color)
                    col = gd.ROIs.rois(r).color;
                elseif get(gd.ROI.color, 'Value') == 1
                    col = gd.Internal.ROIs.colors.random(rem(r,gd.Internal.ROIs.nColors)+1,:);
                elseif get(gd.ROI.color, 'Value') == 2
                    label = DetermineLabel(gd.ROIs.rois(r).label, gd.Internal.ROIs.labels);
                    col = gd.Internal.ROIs.colors.labels{strcmp(label, gd.Internal.ROIs.labels)};
                end
                % Determine Linewidth
                if r == gd.Internal.ROIs.current
                    linewidth = gd.Internal.Settings.ROILineWidth * 2;
                else
                    linewidth = gd.Internal.Settings.ROILineWidth;
                end
                gd.Internal.ROIs.plothandles(r) = patch(...
                    gd.ROIs.rois(r).vertices(:,1),...
                    gd.ROIs.rois(r).vertices(:,2),...
                    col,...
                    'Parent',               gd.View.axes,...
                    'FaceAlpha',            0,...
                    'EdgeColor',            col,...
                    'LineWidth',            linewidth,...
                    'UIContextMenu',        gd.ROIcontextmenu.handle,...
                    'UserData',             r,...
                    'ButtonDownFcn',        @(hObject,eventdata)ROIClickCallback(hObject,eventdata,guidata(hObject))); % display ROI
                if get(gd.ROI.showIDs, 'Value')
                    text(...
                        gd.ROIs.rois(r).vertices(1,1),...
                        gd.ROIs.rois(r).vertices(1,2),...
                        num2str(r),...
                        'Color',                [1,1,1],...
                        'FontSize',             gd.Internal.Settings.ROITextSize); % display ROI's index on screen
                end
                
            else % current ROI is currently being edited
                switch gd.ROIs.rois(r).type
                    case 'ellipse'
                        gd.ROIs.rois(r).handle = imellipse(gd.View.axes, gd.ROIs.rois(r).position);
                        setPositionConstraintFcn(gd.ROIs.rois(r).handle, fcnE);
                    case 'polygon'
                        if length(gd.ROIs.rois(r).vertices) > 40 % too many vertices, too difficult for user to adjust shape, display ui ROI with fewer vertices
                            gd.ROIs.rois(r).handle = impoly(gd.View.axes,gd.ROIs.rois(r).vertices(1:round(end/10):end,:),'Closed',1);
                        else
                            gd.ROIs.rois(r).handle = impoly(gd.View.axes,gd.ROIs.rois(r).vertices,'Closed',1);
                        end
                        setPositionConstraintFcn(gd.ROIs.rois(r).handle, fcnP);
                end
            end
        end
    end
    hold off;
    %     end
end

% Display Running displayspeed
if get(gd.LoadExperiment.showRunSpeed, 'Value')
    text(gd.Images.Width,gd.Images.Height,sprintf('%.0f%s',round(gd.Experiment.frames.RunningSpeed(frameIndex)),'deg/s'),'Color',gd.Internal.Settings.RunSpeedColor,...
        'FontSize',gd.Internal.Settings.RunSpeedSize,'FontWeight','bold','HorizontalAlignment','right',...
        'VerticalAlignment','bottom','uicontextmenu',gd.Textcontextmenu.handle,'UserData','RunningSpeed');
end

% Display Stimulus Mark
if get(gd.LoadExperiment.showStimMark, 'Value')
    if ~isnan(gd.Experiment.frames.Stimulus(frameIndex)) && gd.Experiment.frames.Stimulus(frameIndex)~=0
        text(gd.Images.Width-30,gd.Images.Height-18,sprintf('%d',gd.Experiment.frames.Stimulus(frameIndex)),'Color',gd.Internal.Settings.StimMarkColor,...
            'FontSize',gd.Internal.Settings.StimMarkSize,'FontWeight','bold','HorizontalAlignment','right',...
            'VerticalAlignment','bottom','uicontextmenu',gd.Textcontextmenu.handle,'UserData','StimMark');
        %         hold on
        %         mark=plot(W-25,H-25,'ro');
        %         set(mark,'MarkerFaceColor','r','MarkerSize',18)
        %         hold off
    end
end

%display holographically targetable area
if isfield(gd.Holo,'dispTarget') && gd.Holo.dispTarget==1 && isfield(gd.Holo,'targetRect')
    rectangle(...
        'Position',gd.Holo.targetRect(depthIndex,:),...
        'EdgeColor','r',...
        'LineWidth',1,...
        'Curvature',0.25);
end


guidata(gd.fig,gd); % update guidata
updateGUI(gd);

function label = DetermineLabel(inputLabel, labels)
label = inputLabel;
if isempty(inputLabel)
    label = [label, {'none'}];
elseif numel(inputLabel) > 1
    label = [label, {'multiple'}];
end
other = false;
for l = 1:numel(inputLabel)
    if ~any(strcmp(inputLabel{l}, labels))
        other = true;
    end
end
if other
    label = [label, {'other'}];
end
go = false;
l = 1;
while ~go
    if any(strcmp(labels{l}, label))
        label = labels{l};
        go = true;
    else
        l = l + 1;
    end
end

function frame = getFrame(frame, channel, gd)
switch gd.Images.type
    case '.tif'
        if isnumeric(frame)
            frame = gd.Images.frames(:,:,channel,frame);
        elseif strcmp(frame, 'all')
            frame = gd.Images.frames(:,:,channel,:);
        end
%     case '.sbx'
%         if isnumeric(frame)
%             frame = gd.Images.frames(channel,:,:,frame);
%         elseif strcmp(frame, 'all')
%             frame = gd.Images.frames(channel,:,:,:);
%         end
    case {'.sbx', '.imgs'}
        if isnumeric(frame)
            frame = gd.Images.frames(:,:,1,channel,frame);
        elseif strcmp(frame, 'all')
            frame = gd.Images.frames(:,:,1,channel,:);
        end
end
if ~isa(frame, 'double')
    frame = double(frame);
end

function string = struct2string(structure, exceptions, string)
if ~exist('exceptions', 'var')
    exceptions = {};
end
if ~exist('string', 'var')
    string = '';
end
fns = fieldnames(structure);
data = struct2cell(structure);
for index = 1:length(fns)
    if ~any(strcmp(exceptions, fns{index})) && ~isstruct(data{index})
        if isnumeric(data{index}) || islogical(data{index})
            data{index} = mat2str(data{index});
        elseif iscellstr(data{index}) && ~isempty(data{index})
            data{index} = cell2mat(strcat(data{index}, ','));
            data{index}(end) = [];
        end
        if ischar(data{index})
            string = [string, sprintf('%s: %s\n', fns{index}, data{index})];
        end
    end
end

function updateGUI(gd)
% ROI Selected gd.Internal.ROIs.current~=false
% ROIs available
if ~isempty(gd.ROIs.rois) && ~all([gd.ROIs.rois(:).beingEdited]) && get(gd.ROI.show, 'Value')
    set([gd.ROI.edit,gd.ROI.editAll,gd.ROI.deleteAll,gd.ROI.saveFile], 'Enable', 'on');
else
    set([gd.ROI.edit,gd.ROI.editAll,gd.ROI.deleteAll,gd.ROI.saveFile], 'Enable', 'off');
end
% ROI being edited
switch gd.state.UIstate
    case 'ready'
        set([gd.ROI.add], 'Enable', 'on');
        set([gd.ROI.delete, gd.ROI.save], 'Enable', 'off');
    case 'ROIedit'
        set([gd.ROI.add], 'Enable', 'off');
        set([gd.ROI.delete, gd.ROI.save], 'Enable', 'on');
end

%% LOAD IMAGES
function LoadImages(hObject, eventdata, gd)

% Remove Old Session
gd.Images = [];

% Determine Files and Load Configuration
if iscell(eventdata) % arguments specified in function call
    
    Files = eventdata{1};
    gd.Images.loadType = eventdata{2};
    Frames = eventdata{3};
    CHannels = eventdata{4};
    
else % gui button pressed
    
    % Determine file(s) to load
    if isdir(gd.Internal.directory)
        directory = gd.Internal.directory;
    elseif exist('CanalSettings.m', 'file');
        directory = CanalSettings('DataDirectory');
    else
        directory = cd;
    end
    [Files, p] = uigetfile({'*.tif;*.sbx;*.imgs'}, 'Choose image file(s)', directory, 'MultiSelect', 'on'); % select files
    if isnumeric(Files) % user hit cancel
        return
    elseif iscellstr(Files)
        for F = 1:numel(Files)
            Files{F} = fullfile(p, Files{F});
        end
    else
        Files = {fullfile(p, Files)};
    end
    
    % Load Type
    loadingtypes = get(gd.LoadImages.type, 'String');
    gd.Images.loadType = loadingtypes{get(gd.LoadImages.type, 'Value')};
    
    % Determine frames to load
    Frames = get(gd.LoadImages.frames, 'String');
    if isempty(Frames) || (ischar(Frames) && any(strcmp(Frames, {'all', 'Frames: all'})));
        Frames = [1 inf];
    else
        Frames = str2num(Frames);
    end
    
    % Determine channels to load
    Channels = get(gd.LoadImages.channels, 'String');
    if isempty(Channels) || (ischar(Channels) && any(strcmp(Channels, {'all', 'Channels: all'})));
        Channels = [1 inf];
    else
        Channels = str2num(Channels);
    end
    
end

% Save Filenames
gd.Images.filenames = Files;
gd.Images.nFiles = numel(Files);
[gd.Internal.directory,gd.Internal.basename,gd.Images.type] = fileparts(Files{1}); % save directory
guidata(hObject, gd); % save directory

% Load Frames and Acquisition Information
switch gd.Images.loadType
    case {'Direct', 'direct'}
        [gd.Images.frames, gd.Images.info] = load2P(gd.Images.filenames, 'Type', 'Direct', 'Channels', Channels, 'Frames', Frames);
    case {'MemMap', 'memmap'}
        [gd.Images.frames, gd.Images.info] = load2P(gd.Images.filenames, 'Type', 'MemMap');
%         if strcmp(gd.Images.info.files(1).ext, '.sbx')
%             gd.Images.frames = intmax(loadObj.Precision) - gd.Images.frames;
%         end
end

% Determine dimensions
[gd.Images.Height, gd.Images.Width, gd.Images.Depth, gd.Images.nChannels, gd.Images.nFrames] = size(gd.Images.frames);

% Update computation selection table
gd.Images.Computations.Names = gd.Internal.Images.defaultComputations;
set(gd.DataSelection.computation, 'String', gd.Images.Computations.Names, 'Value', 1);

% Determine Colormap
for c = 1:gd.Images.nChannels
    img = double(gd.Images.frames(:,:,1:min(end,50),c,1:min(end,50)));
%     gd.state.(gd.Images.Computations.Names{1}).clim(c).limits=[min(img(:)),max(img(:))];
    rangeExpand = intmax(gd.Images.info.Precision)*0.01;
    gd.state.(gd.Images.Computations.Names{1}).clim(c).limits = [min(img(:))-double(rangeExpand) max(img(:))+double(rangeExpand)];%[double(intmin(gd.Images.info.Precision)), double(intmax(gd.Images.info.Precision))];
    gd.state.(gd.Images.Computations.Names{1}).clim(c).current = [min(img(:)), prctile(img(:),99.99)];
    set(gd.View.axes,'CLim',gd.state.(gd.Images.Computations.Names{1}).clim(c).current);
    gd.state.(gd.Images.Computations.Names{1}).colormap(c).orig = colormap;
    gd.state.(gd.Images.Computations.Names{1}).colormap(c).current = gd.state.(gd.Images.Computations.Names{1}).colormap(c).orig;
end

% Update channel selection table
if gd.Images.nChannels == 1
    set(gd.DataSelection.channel,'Data',{true, 'Green'});
    gd.state.channels = true;
    gd.state.channelcolors = {'Green'};
elseif gd.Images.nChannels == 2
    set(gd.DataSelection.channel,'Data',{true, 'Green'; false, 'Red'});
    gd.state.channels = [true, false];
    gd.state.channelcolors = {'Green','Red'};
else
    error('Too many channels for current version of editor');
end
minorstep = 1/(gd.state.(gd.Images.Computations.Names{1}).clim(1).limits(2)-gd.state.(gd.Images.Computations.Names{1}).clim(1).limits(1));
set(gd.DataSelection.climMin,...
    'Min',          gd.state.(gd.Images.Computations.Names{1}).clim(1).limits(1),...
    'Max',          gd.state.(gd.Images.Computations.Names{1}).clim(1).limits(2),...
    'Value',        gd.state.(gd.Images.Computations.Names{1}).clim(1).current(1),...
    'SliderStep',   [minorstep,max(2*minorstep,.01)],...
    'Enable',       'on');
set(gd.DataSelection.climMinText,...
    'String',       num2str(round(gd.state.(gd.Images.Computations.Names{1}).clim(gd.state.channels).current(1))),...
    'Visible',      'on');
set(gd.DataSelection.climMax,...
    'Min',          gd.state.(gd.Images.Computations.Names{1}).clim(1).limits(1),...
    'Max',          gd.state.(gd.Images.Computations.Names{1}).clim(1).limits(2),...
    'Value',        gd.state.(gd.Images.Computations.Names{1}).clim(1).current(2),...
    'SliderStep',   [minorstep,max(2*minorstep,.01)],...
    'Enable',       'on');
set(gd.DataSelection.climMaxText,...
    'String',       num2str(round(gd.state.(gd.Images.Computations.Names{1}).clim(gd.state.channels).current(2))),...
    'Visible',      'on');

% Save guidata
gd.state.dataAvailable = true;
gd.state.UIstate = 'ready';
gd.state.currentFrame = 1;
gd.state.currentDepth = 1;
guidata(hObject,gd); % update guidata

% Update GUI
exceptions = {'FrameIndex'};
string = sprintf('%s\n', gd.Images.filenames{1});
set(gd.LoadImages.info,...
    'String',       struct2string(gd.Images.info, exceptions, string),...
    'Value',        1);
contents = get(gd.ExportData.selection, 'String'); % add to export list
set(gd.ExportData.selection, 'String', [contents; {'Image Filename';'Images';'loadObj'}], 'Value', 1);
if gd.Images.nFrames > 1 % frame slider
    minorstep = 1/(gd.Images.nFrames-1);
    set(gd.View.frameSlider,...
        'Enable',       'on',...
        'Min',          1,...
        'Max',          gd.Images.nFrames,...
        'Value',        1,...
        'SliderStep',   [minorstep,max(2*minorstep,.1)]); %[1/(gd.Images.nFrames-1),round(gd.Images.nFrames/50)/(gd.Images.nFrames-1)]
else
    set(gd.View.frameSlider,...
        'Min',          1,...
        'Max',          1,...
        'Value',        1);
end
if gd.Images.Depth > 1 % depth slider
    minorstep = 1/(gd.Images.Depth-1);
     set(gd.View.depthSlider,...
        'Enable',       'on',...
        'Min',          1,...
        'Max',          gd.Images.Depth,...
        'Value',        1,...
        'SliderStep',   [minorstep,max(2*minorstep,.1)]); %[1/(gd.Images.nFrames-1),round(gd.Images.nFrames/50)/(gd.Images.nFrames-1)]
    set(gd.ROI.showDepth, 'Enable', 'on');
else
     set(gd.View.depthSlider,...
        'Min',          1,...
        'Max',          1,...
        'Value',        1);
end

% Determine if you should reset target area
if ~isfield(gd,'Holo') || ~isfield(gd.Holo,'optotuneDepths') || ~isfield(gd.Holo,'zoom')
    gd.Holo.recalcTargetArea =1;
else
    meta = ScanImageTiffReader(gd.Images.info.files.FullFilename).metadata();
    SI = parseSI5Header(meta);
    
    newOptotuneDepths= SI.SI.hStackManager.zs;
    newZoom= SI.SI.hRoiManager.scanZoomFactor;
    if ( numel(newOptotuneDepths)~=numel(gd.Holo.optotuneDepths) ||  newZoom ~= gd.Holo.zoom)
        gd.Holo.zoom = newZoom;
        gd.Holo.optotuneDepths = newOptotuneDepths;
        gd.Holo.recalcTargetArea =1;
    end
end

updateGUI(gd)
plotmainaxes(1,1,gd); % Display First Image of Stack

%% LOAD EXPERIMENT
function LoadExperiment(hObject,eventdata,gd)
if ~ischar(eventdata)
    if isdir(gd.Internal.directory)
        directory = gd.Internal.directory;
    elseif exist('CanalSettings.m', 'file');
        directory = CanalSettings('ExperimentDirectory');
    else
        directory = cd;
    end
    [ExperimentFile, p] = uigetfile({'*.mat;*.ciexp'},'Choose Experiment file',directory);
    if isnumeric(ExperimentFile)
        return
    end
    ExperimentFile = fullfile(p,ExperimentFile);
else
    ExperimentFile = eventdata;
end

% updateExperimentInfo(ExperimentFile); %fix missing info

% Load Experiment Data
gd.Experiment = load(ExperimentFile, 'frames', 'MCdata', 'Date', 'StimuliNames', 'ID', 'Tag', 'Location', 'Depth', 'ImageFiles', '-mat');

% Save file info
gd.Experiment.filename = ExperimentFile;
% Update state
gd.state.experimentAvailable = true;

% Update computations available
if isfield(gd.Experiment,'ImageFiles')
    fields = fieldnames(gd.Experiment.ImageFiles);
    fields(strcmp(fields, 'frames')) = []; % remove frame numbers the images were based on
    fields(strcmp(fields, 'filename')) = [];
    for index = 1:numel(fields)
        gd.Images.Computations.Data.(fields{index}) = gd.Experiment.ImageFiles.(fields{index});
        gd.state.(fields{index}).colormap = gd.state.(gd.Images.Computations.Names{1}).colormap;
        for cindex = 1:size(gd.Images.Computations.Data.(fields{index}), 4)
            temp = gd.Images.Computations.Data.(fields{index})(:,:,:,cindex,1:min(end,5));
            gd.state.(fields{index}).clim(cindex).limits = [min(temp(:)), max(temp(:))];
            gd.state.(fields{index}).clim(cindex).current = [gd.state.(fields{index}).clim(cindex).limits(1), prctile(temp(:),99.98)];
        end
    end
    gd.Images.Computations.Names = [gd.Internal.Images.defaultComputations; fields(1:end)];
    set(gd.DataSelection.computation, 'String', gd.Images.Computations.Names);
end

% Update motion correction availability
if isfield(gd.Experiment, 'MCdata')
    set(gd.LoadExperiment.MC, 'Enable', 'on');
else
    set(gd.LoadExperiment.MC, 'Value', false, 'Enable', 'off');
end

% Update stim mark and running speed
if isfield(gd.Experiment, 'frames')
    Objects = [gd.LoadExperiment.showStimMark, gd.LoadExperiment.showRunSpeed];
    Fields = {'Stimulus', 'RunningSpeed'};
    temp = isfield(gd.Experiment.frames, Fields);
    set(Objects(temp), 'Enable', 'on');
end

% Update info box
string = sprintf('%s\n', gd.Experiment.filename);
set(gd.LoadExperiment.info, 'String', struct2string(gd.Experiment, {'Intervals','Stimuli', 'TrialInfo', 'Triggers'}, string));

% Add to export list
contents = get(gd.ExportData.selection, 'String'); % add to export list
set(gd.ExportData.selection, 'String', [contents; {'Experiment Filename';'Experiment'}], 'Value', 1);

guidata(hObject, gd);

function ExperimentInfo(hOject,eventdata,gd)

function DisplayTimeline(hObject,eventdata,gd)

%% SELECTING DATA
function DataSelection(hObject,eventdata,gd)
gd.state.channels(eventdata.Indices(1)) = eventdata.NewData;
if sum(gd.state.channels) == 1
    set([gd.DataSelection.climMin, gd.DataSelection.climMax], 'Enable', 'on');
    set([gd.DataSelection.climMinText, gd.DataSelection.climMaxText], 'Visible', 'on');
    Computation = gd.Images.Computations.Names{get(gd.DataSelection.computation, 'Value')};
    set(gd.DataSelection.climMin,...
        'Min',          gd.state.(Computation).clim(gd.state.channels).limits(1),...
        'Max',          gd.state.(Computation).clim(gd.state.channels).limits(2),...
        'Value',        gd.state.(Computation).clim(gd.state.channels).current(1));
    set(gd.DataSelection.climMinText, 'String', num2str(round(gd.state.(Computation).clim(gd.state.channels).current(1))));
    set(gd.DataSelection.climMax,...
        'Min',          gd.state.(Computation).clim(gd.state.channels).limits(1),...
        'Max',          gd.state.(Computation).clim(gd.state.channels).limits(2),...
        'Value',        gd.state.(Computation).clim(gd.state.channels).current(2));
    set(gd.DataSelection.climMaxText, 'String', num2str(round(gd.state.(Computation).clim(gd.state.channels).current(2))));
else
    set([gd.DataSelection.climMin, gd.DataSelection.climMax], 'Enable', 'off');
    set([gd.DataSelection.climMinText, gd.DataSelection.climMaxText], 'Visible', 'off');
end
guidata(hObject, gd);
plotmainaxes([],[],gd);

function ClimMinimum(hObject,eventdata,gd)
Computation = gd.Images.Computations.Names{get(gd.DataSelection.computation, 'Value')};
NewValue = round(get(hObject, 'Value'));
NewValue = max(NewValue,gd.state.(Computation).clim(gd.state.channels).limits(1));
if NewValue >= gd.state.(Computation).clim(gd.state.channels).current(2)
    gd.state.(Computation).clim(gd.state.channels).current(1) = gd.state.(Computation).clim(gd.state.channels).current(2)-1;
    set(hObject, 'Value', gd.state.(Computation).clim(gd.state.channels).current(1));
    NewValue = gd.state.(Computation).clim(gd.state.channels).current(1);
else
    gd.state.(Computation).clim(gd.state.channels).current(1) = NewValue;
end
set(gd.DataSelection.climMinText, 'String', num2str(round(NewValue)));
guidata(hObject, gd);
plotmainaxes([],[],gd);

function ClimMaximum(hObject,eventdata,gd)
Computation = gd.Images.Computations.Names{get(gd.DataSelection.computation, 'Value')};
NewValue = round(get(hObject, 'Value'));
NewValue = min(NewValue,gd.state.(Computation).clim(gd.state.channels).limits(2));
if NewValue <= gd.state.(Computation).clim(gd.state.channels).current(1)
    gd.state.(Computation).clim(gd.state.channels).current(2) = gd.state.(Computation).clim(gd.state.channels).current(1)+1;
    set(hObject, 'Value', gd.state.(Computation).clim(gd.state.channels).current(2));
    NewValue = gd.state.(Computation).clim(gd.state.channels).current(2);
else
    gd.state.(Computation).clim(gd.state.channels).current(2) = NewValue;
end
set(gd.DataSelection.climMaxText, 'String', num2str(round(NewValue)));
guidata(hObject, gd);
plotmainaxes([],[],gd);

function ViewSelection(hObject,eventData,gd)
if sum(gd.state.channels) == 1
    Computation = gd.Images.Computations.Names{get(hObject, 'Value')};
    set(gd.DataSelection.climMin,...
        'Min',          gd.state.(Computation).clim(gd.state.channels).limits(1),...
        'Max',          gd.state.(Computation).clim(gd.state.channels).limits(2),...
        'Value',        gd.state.(Computation).clim(gd.state.channels).current(1));
    set(gd.DataSelection.climMinText, 'String', num2str(round(gd.state.(Computation).clim(gd.state.channels).current(1))));
    set(gd.DataSelection.climMax,...
        'Min',          gd.state.(Computation).clim(gd.state.channels).limits(1),...
        'Max',          gd.state.(Computation).clim(gd.state.channels).limits(2),...
        'Value',        gd.state.(Computation).clim(gd.state.channels).current(2));
    set(gd.DataSelection.climMaxText, 'String', num2str(round(gd.state.(Computation).clim(gd.state.channels).current(2))));
end
plotmainaxes([],[],gd);

function ComputeComputation(hObject,eventdata,gd)
current = gd.DataSelection.computationAvail.String(gd.DataSelection.computationAvail.Value);
switch current{1}
    case 'Average'
        gd.Images.Computations.Data.Average = mean(gd.Images.frames, 5);
        gd.state.Average.colormap = gd.state.(gd.Images.Computations.Names{1}).colormap;
        for cindex = 1:size(gd.Images.Computations.Data.Average, 4)
            temp = gd.Images.Computations.Data.Average(:,:,:,cindex,:);
            rangeExpand = double(floor(intmax(gd.Images.info.Precision)*0.01));
            gd.state.Average.clim(cindex).limits = [min(temp(:))-rangeExpand, max(temp(:))+rangeExpand];
            gd.state.Average.clim(cindex).current = [min(temp(:)), prctile(temp(:),99.98)];
        end
        gd.Images.Computations.Names = [gd.Images.Computations.Names; 'Average'];
        guidata(hObject, gd);
        set(gd.DataSelection.computation, 'String', gd.Images.Computations.Names);
    case 'DFF'
%       written by ian 11/3/2017 
%       makes DF/F average image from first 1s of recording

        FR = gd.Images.info.FrameRate/gd.Images.info.Depth;
        gd.Images.Computations.Data.BaseLine = mean(gd.Images.frames(:,:,:,:,1:round(FR)), 5); %baseline is mean of first 1s
%         gd.Images.Computations.Data.BaseLine = double(prctile(gd.Images.frames, 10,10));
        minVal = min(gd.Images.Computations.Data.BaseLine(:));
        if minVal>0
            minVal=0;
        end
        gd.Images.Computations.Data.DFF = bsxfun(@rdivide,(double(gd.Images.frames)-minVal),(gd.Images.Computations.Data.BaseLine-minVal));
%         gd.Images.Computations.Data.averageDFF = imgaussfilt(mean( gd.Images.Computations.Data.DFF(:,:,:,:,round(FR):round(FR*2.5)), 5),0.5)*100;
        gd.Images.Computations.Data.averageDFF = imgaussfilt(mean( gd.Images.Computations.Data.DFF, 5),0.5)*100;
        
        gd.state.averageDFF.colormap = gd.state.(gd.Images.Computations.Names{1}).colormap;
        for cindex = 1:size(gd.Images.Computations.Data.averageDFF, 4)
            temp = gd.Images.Computations.Data.averageDFF(:,:,:,cindex,:);
            rangeExpand = double(floor(intmax(gd.Images.info.Precision)*0.01));
            gd.state.averageDFF.clim(cindex).limits = [min(temp(:))-rangeExpand, max(temp(:))+rangeExpand];
            gd.state.averageDFF.clim(cindex).current = [min(temp(:)), prctile(temp(:),99.98)];
        end
        gd.Images.Computations.Names = [gd.Images.Computations.Names; 'averageDFF'];
        guidata(hObject, gd);
        set(gd.DataSelection.computation, 'String', gd.Images.Computations.Names);

 case 'ComputeAverageMovs'
        
%         try
%         FR = gd.Images.info.FrameRate/gd.Images.info.Depth;
%         catch
%             FR=5.8;
%         end
        meanMovs = alignTrialTypes;
        
        
        %Mov1
        gd.Images.Computations.Data.Mov1 = meanMovs{1}; %baseline is mean of first 1s
        
        gd.state.Mov1.colormap = gd.state.(gd.Images.Computations.Names{1}).colormap;
        for cindex = 1:size(gd.Images.Computations.Data.Mov1, 4)
            temp = gd.Images.Computations.Data.Mov1(:,:,:,cindex,:);
            rangeExpand = double(floor(intmax(gd.Images.info.Precision)*0.01));
            gd.state.Mov1.clim(cindex).limits = [min(temp(:))-rangeExpand, max(temp(:))+rangeExpand];
            gd.state.Mov1.clim(cindex).current = [min(temp(:)), prctile(temp(:),99.98)];
        end
        gd.Images.Computations.Names = [gd.Images.Computations.Names; 'Mov1'];
        guidata(hObject, gd);
        set(gd.DataSelection.computation, 'String', gd.Images.Computations.Names);
        
        %Mov2
        gd.Images.Computations.Data.Mov2 = meanMovs{2}; %baseline is mean of first 1s
        
        gd.state.Mov2.colormap = gd.state.(gd.Images.Computations.Names{1}).colormap;
        for cindex = 1:size(gd.Images.Computations.Data.Mov2, 4)
            temp = gd.Images.Computations.Data.Mov2(:,:,:,cindex,:);
            rangeExpand = double(floor(intmax(gd.Images.info.Precision)*0.01));
            gd.state.Mov2.clim(cindex).limits = [min(temp(:))-rangeExpand, max(temp(:))+rangeExpand];
            gd.state.Mov2.clim(cindex).current = [min(temp(:)), prctile(temp(:),99.98)];
        end
        gd.Images.Computations.Names = [gd.Images.Computations.Names; 'Mov2'];
        guidata(hObject, gd);
        set(gd.DataSelection.computation, 'String', gd.Images.Computations.Names);
        
                %Mov3
        gd.Images.Computations.Data.Mov3 = meanMovs{3}; %baseline is mean of first 1s
        
        gd.state.Mov3.colormap = gd.state.(gd.Images.Computations.Names{1}).colormap;
        for cindex = 1:size(gd.Images.Computations.Data.Mov3, 4)
            temp = gd.Images.Computations.Data.Mov3(:,:,:,cindex,:);
            rangeExpand = double(floor(intmax(gd.Images.info.Precision)*0.01));
            gd.state.Mov3.clim(cindex).limits = [min(temp(:))-rangeExpand, max(temp(:))+rangeExpand];
            gd.state.Mov3.clim(cindex).current = [min(temp(:)), prctile(temp(:),99.98)];
        end
        gd.Images.Computations.Names = [gd.Images.Computations.Names; 'Mov3'];
        guidata(hObject, gd);
        set(gd.DataSelection.computation, 'String', gd.Images.Computations.Names);
        
                %Mov4
        gd.Images.Computations.Data.Mov4 = meanMovs{4}; %baseline is mean of first 1s
        
        gd.state.Mov4.colormap = gd.state.(gd.Images.Computations.Names{1}).colormap;
        for cindex = 1:size(gd.Images.Computations.Data.Mov4, 4)
            temp = gd.Images.Computations.Data.Mov4(:,:,:,cindex,:);
            rangeExpand = double(floor(intmax(gd.Images.info.Precision)*0.01));
            gd.state.Mov4.clim(cindex).limits = [min(temp(:))-rangeExpand, max(temp(:))+rangeExpand];
            gd.state.Mov4.clim(cindex).current = [min(temp(:)), prctile(temp(:),99.98)];
        end
        gd.Images.Computations.Names = [gd.Images.Computations.Names; 'Mov4'];
        guidata(hObject, gd);
        set(gd.DataSelection.computation, 'String', gd.Images.Computations.Names);

end

%% VIEWING DATA
function FrameSelection(hObject,eventdata,gd)
plotmainaxes(round(get(hObject,'Value')),[],gd);

function DepthSelection(hObject,eventdata,gd)
plotmainaxes([],round(get(hObject,'Value')),gd);

function PlayPause(hObject, eventData, gd)
if get(hObject,'Value')
    set(hObject,'String','Stop')
    if gd.state.currentFrame == gd.Images.nFrames
        index = 0;
    else
        index=gd.state.currentFrame-1;
    end
    while get(hObject,'Value')
        index = round(get(gd.View.frameSlider,'Value')) + 1;
        if index > gd.Images.nFrames
            index = 1;
        end
        tic;
        set(gd.View.frameSlider,'Value',index);
        plotmainaxes(index,[],gd);
        pause(max(toc-1/gd.Internal.Settings.PlayFrameRate,0.001));
    end
    set(hObject,'Value',0,'String','Play')
    
end

function SaveImage(hObject,eventdata,gd)
img = getframe(gd.View.axes); % grab image
% Determine Filename
figure; image(img.cdata);
[f,p] = uiputfile({'*.tif','tif file (*.tif)';...
    '*.jpg','jpeg file (*.jpg)';'*.*','All Files (*.*)'},...
    'Save Image',fullfile(gd.Internal.directory, gd.Internal.basename));
if isnumeric(f) % user hit cancel
    return
end
imwrite(img.cdata,fullfile(p,f)); % save image

function SaveVideo(hObject,eventdata,gd)
% Determine filename
[f,p,~] = uiputfile({'*.avi','AVI video file (*.avi)'},...
    'Save Video', fullfile(gd.Internal.directory, gd.Internal.basename));
if isnumeric(f) % user hit cancel
    return
end
% Determine frame rate
opts = inputdlg({'Frame Rate (Hz):','First Frame','Last Frame'},'Options',1,{num2str(gd.Images.info.FrameRate),num2str(gd.state.currentFrame),num2str(gd.Images.nFrames)});  % get video frame rate
if isempty(opts) % user hit cancel
    return
end
% Create and Save Video
vidObj = VideoWriter(fullfile(p,f),'Motion JPEG AVI');
set(vidObj,'FrameRate',str2num(opts{1}));
open(vidObj);
for currentframe = str2double(opts{2}):str2double(opts{3})
    plotmainaxes(currentframe,[],gd);
    img = getframe(gd.View.axes);
    writeVideo(vidObj,img);
end
close(vidObj);

%% ROIs - High Level
function LoadROIs(hObject,eventdata,gd)

% Select file
[ROIFile,p]=uigetfile({'*.mat','MAT file (*.mat)'},...
    'Choose ROI file to load',gd.Internal.directory);
if isnumeric(ROIFile) % user hit cancel
    return
end
gd.ROIs.filename = fullfile(p, ROIFile);

% Load ROI Data
load(gd.ROIs.filename, 'ROIdata');

% Check if ROIs came from current file
if gd.state.dataAvailable && isfield(ROIdata, 'imagefiles')
    if numel(ROIdata.imagefiles)~=numel(gd.Images.filenames) || ~all(strcmp(ROIdata.imagefiles, gd.Images.filenames)) % different files listed
        warndlg('These ROIs were created off of a different file. Make sure to save to a different ROI file to not lose this information.');
    end
end

% Save offset of data from master reference frame (or set to be master)
if isfield(ROIdata, 'offset')
    gd.ROIs.offset = ROIdata.offset;
else
    gd.ROIs.offset = [0, 0, 0];
end

% Add all fields it has to the internal ROI struct
InternalFields =  {'type','vertices','position','color','tag','label','frame','depth','rawdata','rawneuropil','pixels','mask','neuropilmask'};
FieldsInFile = isfield(ROIdata.rois, InternalFields);
LoadedFields = fieldnames(ROIdata.rois);
ExtraFields = find(~ismember(LoadedFields,InternalFields));
for currentroi = 1:numel(ROIdata.rois) % save each loaded ROI
    gd.Internal.ROIs.n = gd.Internal.ROIs.n + 1; % increment index
    for currentfield = 1:numel(InternalFields) % save information generated internally
        if FieldsInFile(currentfield)
            gd.ROIs.rois(gd.Internal.ROIs.n).(InternalFields{currentfield}) = ROIdata.rois(currentroi).(InternalFields{currentfield});
        else
            gd.ROIs.rois(gd.Internal.ROIs.n).(InternalFields{currentfield}) = [];
        end
    end
    if ~isempty(ExtraFields) % save information generated externally from GUI
        for currentfield = 1:numel(ExtraFields)
            gd.ROIs.rois(gd.Internal.ROIs.n).(LoadedFields{ExtraFields(currentfield)}) = ROIdata.rois(currentroi).(LoadedFields{ExtraFields(currentfield)});
        end
    end
    gd.ROIs.rois(gd.Internal.ROIs.n).beingEdited = false; % loaded ROI is not being edited
    gd.ROIs.rois(gd.Internal.ROIs.n).handle = [];
end
if ~gd.state.dataAvailable
    gd.Images.nFrames = 1;
    gd.Images.nChannels = 1;
    gd.Images.filenames = {''};
    gd.Images.Height = size(ROIdata.totalmask, 1);
    gd.Images.Width = size(ROIdata.totalmask, 2);
    gd.Images.type = '.tif';
    gd.Images.frames = zeros(gd.Images.Height, gd.Images.Width);
end

% Add to export list
contents = get(gd.ExportData.selection, 'String'); % add to export list
set(gd.ExportData.selection, 'String', [contents; {'ROIs Filename';'ROIs'}], 'Value', 1);

guidata(hObject,gd); % update guidata
updateGUI(gd)
plotmainaxes([],[],gd); % Display current image with ROIs overlayed

function SaveROIs(hObject,eventdata,gd)
[~,f,~]=fileparts(gd.Images.filenames{1});
[f,p] = uiputfile('*.mat','Save ROI file as',sprintf('%s_rois',fullfile(gd.Internal.directory,f)));
if f==0
    return
end
gd.ROIs.filename = fullfile(p,f); % save filename
gd.ROIs.imagefiles = gd.Images.filenames; % save dataset ROIs were pulled from
guidata(hObject, gd);
set(gcf, 'pointer', 'watch')
gd = CreateROIMasks(gd);
gd = CreateROINeuropilMasks(gd);
ROIdata=gd.ROIs; % pull out ROI information
ROIdata.rois = rmfield(ROIdata.rois, {'handle','beingEdited'}); % remove fields used for editing ROIs
VariablesToSave = {'ROIdata'};
if gd.state.dataAvailable
    ImagesInfo = gd.Images.info;
    VariablesToSave = [VariablesToSave,{'ImagesInfo'}];
end
if gd.state.experimentAvailable
%     Experiment.Date = gd.Experiment.Date;
%     Experiment.StimuliNames = gd.Experiment.StimuliNames;
%     Experiment.ID = gd.Experiment.ID;
%     Experiment.Tag = gd.Experiment.Tag;
%     Experiment.Location = gd.Experiment.Location;
%     Experiment.Depth = gd.Experiment.Depth;
%     VariablesToSave = [VariablesToSave,{'Experiment'}];
%     if isfield(gd.Experiment, 'frames')
%         frames = gd.Experiment.frames;
%         VariablesToSave = [VariablesToSave,{'frames'}];
%     end
end
drawnow
if exist(fullfile(p,f), 'file')
    save(fullfile(p,f),VariablesToSave{:},'-append','-mat');
else
    save(fullfile(p,f),VariablesToSave{:},'-mat');
end
set(gcf, 'pointer', 'arrow')
fprintf('ROIs saved to: %s \n', fullfile(p,f));

function gd = CreateROIMasks(gd)
wb = waitbar(0,'Locating ROIs');
for currentroi = 1:gd.Internal.ROIs.n
    if ~isfield(gd.ROIs.rois, 'pixels') || isempty(gd.ROIs.rois(currentroi).pixels) % mask has yet to be created for ROI
        switch gd.ROIs.rois(currentroi).type % create ROIs mask
            case 'ellipse'
                gd.ROIs.rois.handle = imellipse(gd.View.axes,gd.ROIs.rois(currentroi).position);
            case 'polygon'
                gd.ROIs.rois.handle = impoly(gd.View.axes,gd.ROIs.rois(currentroi).vertices,'Closed',1);
        end
        gd.ROIs.rois(currentroi).pixels = createMask(gd.ROIs.rois.handle); % extract mask
        delete(gd.ROIs.rois.handle); % delete temporary UI ROI
    end
    waitbar(currentroi/gd.Internal.ROIs.n,wb);
end
close(wb);
wb = waitbar(0, 'Defining ROI masks');
gd.ROIs.totalmask = reshape([gd.ROIs.rois(:).pixels], gd.Images.Height, gd.Images.Width, gd.Internal.ROIs.n);
gd.ROIs.totalmask = sum(gd.ROIs.totalmask, 3);
overlapping_regions = gd.ROIs.totalmask > 1;
gd.ROIs.totalmask = logical(gd.ROIs.totalmask);
for currentroi = 1:gd.Internal.ROIs.n
    mask = (gd.ROIs.rois(currentroi).pixels - overlapping_regions) > 0; % remove averaging pixels that contain another cell
    if ~isfield(gd.ROIs.rois, 'mask') || isempty(gd.ROIs.rois(currentroi).mask) || ~isequal(gd.ROIs.rois(currentroi).mask, mask) % mask newly created or new cell encroached
        gd.ROIs.rois(currentroi).mask = mask;
        gd.ROIs.rois(currentroi).rawdata = [];
    end
    waitbar(currentroi/gd.Internal.ROIs.n,wb);
end
guidata(gd.fig, gd);
close(wb);

function gd = CreateROINeuropilMasks(gd)
wb = waitbar(0,'Creating Neuropil masks');
for currentroi = 1:gd.Internal.ROIs.n
    se = strel('square', gd.Internal.Settings.NeuropilDistance);
    mask = imdilate(gd.ROIs.rois(currentroi).pixels, se) - gd.ROIs.rois(currentroi).pixels;
    mask = (mask - gd.ROIs.totalmask) > 0;
    if ~isfield(gd.ROIs.rois, 'neuropilmask') || isempty(gd.ROIs.rois(currentroi).neuropilmask) || ~isequal(gd.ROIs.rois(currentroi).neuropilmask, mask) % newly calculated mask or new cell encroached on neuropil
        gd.ROIs.rois(currentroi).neuropilmask = mask;
        gd.ROIs.rois(currentroi).rawneuropil = [];
    end
    waitbar(currentroi/gd.Internal.ROIs.n,wb);
end
gd.ROIs.totalneuropilmask = reshape([gd.ROIs.rois(:).neuropilmask], gd.Images.Height, gd.Images.Width, gd.Internal.ROIs.n);
gd.ROIs.totalneuropilmask = logical(sum(gd.ROIs.totalneuropilmask, 3));
guidata(gd.fig, gd);
close(wb);

function DeleteAllROIs(hObject, eventData, gd)
answer = questdlg('Are you sure?','Delete All ROIs','Yes','No','Yes');
if strcmp(answer, 'No')
    return
end
gd.ROIs.rois = [];
gd.ROIs.offset = [0,0,0];
gd.Internal.ROIs.n = 0;
% Update GUI
gd.state.UIstate = 'ready';
guidata(hObject,gd);
updateGUI(gd);
plotmainaxes([],[],gd);

function AddROILabel(hObject,eventdata,gd)
answer = inputdlg('Enter new label:', 'Add Label', 1);
if isempty(answer) || any(strcmp(answer{1}, {'other', 'multiple', 'none'}))
    return
else
    % update internal
    gd.Internal.ROIs.nlabels = gd.Internal.ROIs.nlabels + 1;
    gd.Internal.ROIs.labels = [gd.Internal.ROIs.labels, answer];
    gd.Internal.ROIs.colors.labels = [gd.Internal.ROIs.colors.labels, {'red'}];
    % update context menu
    gd.ROIcontextmenu.menus(gd.Internal.ROIs.nlabels).label = gd.Internal.ROIs.labels{gd.Internal.ROIs.nlabels};
    gd.ROIcontextmenu.menus(gd.Internal.ROIs.nlabels).handle = uimenu(...
        'Parent',               gd.ROIcontextmenu.handle,...
        'Label',                answer{1},...
        'Tag',                  num2str(gd.Internal.ROIs.nlabels),...
        'Position',             gd.Internal.ROIs.nlabels,...
        'Callback',             @(hObject,eventdata)ROIlabel(hObject,eventdata,guidata(hObject)));
    set(gd.ROIcontextmenu.other, 'Position', gd.Internal.ROIs.nlabels + 1);
    set(gd.ROIcontextmenu.color, 'Position', gd.Internal.ROIs.nlabels + 2);
    guidata(hObject, gd);
    % update gui
    data = get(gd.ROI.labels, 'Data');
    data(end+1,:) = {answer{1}, 'red', false, false, false};
    set(gd.ROI.labels, 'Data', data);
end

function EditLabelsTable(hObject,eventdata,gd)
if eventdata.Indices(2) == 2 % switch color
    testnum = str2num(eventdata.NewData);
    if ~isempty(testnum) && numel(testnum)==3 % input is 'numeric'
        if any(testnum>1) || any(testnum<0) % validate input
            data = get(hObject, 'Data');
            data{eventdata.Indices(1),eventdata.Indices(2)} = eventdata.PreviousData;
            set(hObject, 'Data', data);
            return
        end
        mat = str2num(eventdata.NewData);
        gd.Internal.ROIs.colors.labels{eventdata.Indices(1)} = mat; % update internal
    else % 'char'
        if ~any(strcmp(eventdata.NewData, {'y','m','c','r','g','b','w','k','yellow','magenta','cyan','red','green','blue','white','black'})) % validate input
            data = get(hObject, 'Data');
            data{eventdata.Indices(1),eventdata.Indices(2)} = eventdata.PreviousData;
            set(hObject, 'Data', data);
            return
        end
        gd.Internal.ROIs.colors.labels{eventdata.Indices(1)} = eventdata.NewData; % update internal
    end
else % switch ordering or delete label
    data = get(hObject, 'Data');
    data{eventdata.Indices(1),eventdata.Indices(2)} = false; % uncheck box
    if eventdata.Indices(2) == 3 && eventdata.Indices(1) ~= 1 % move up
        data(eventdata.Indices(1):end+1,:) = data(eventdata.Indices(1)-1:end,:); %shift
        data(eventdata.Indices(1)-1,:) = data(eventdata.Indices(1)+1,:); %add to new location
        data(eventdata.Indices(1)+1,:) = []; %remove previous location
    elseif eventdata.Indices(2) == 4 && eventdata.Indices(1) ~= size(data,1) % move down
        data(eventdata.Indices(1)+1:end+1,:) = data(eventdata.Indices(1):end,:); %shift
        data(eventdata.Indices(1),:) = data(eventdata.Indices(1)+2,:); %add to new location
        data(eventdata.Indices(1)+2,:) = []; %remove previous location
    elseif eventdata.Indices(2) == 5 % Remove from list
        label = data{eventdata.Indices(1), 1}; % label selected
        if ~strcmp(label, {'other', 'multiple', 'none'}); % only remove user defined labels
            % update internal
            gd.Internal.ROIs.nlabels = gd.Internal.ROIs.nlabels - 1;
            % update context menu
            index = strcmp(label, {gd.ROIcontextmenu.menus(:).label});
            delete(gd.ROIcontextmenu.menus(index).handle);
            gd.ROIcontextmenu.menus(index) = [];
            % update gui
            data(eventdata.Indices(1),:) = [];
        end
    end
    set(hObject, 'Data', data);
    gd.Internal.ROIs.labels = data(:,1)'; %update internal
    gd.Internal.ROIs.colors.labels = data(:,2)'; %update internal
end
guidata(hObject, gd); % save guidata
if gd.Internal.ROIs.n % if ROIs exist, replot axes
    plotmainaxes([],[],gd);
end

function EditAllROIs(hObject,eventdata,gd)
if gd.Internal.ROIs.n
    for r = 1:gd.Internal.ROIs.n
        gd.ROIs.rois(r).beingEdited = true;
    end
    gd.state.UIstate='ROIedit'; % save current state
    guidata(hObject, gd);
    updateGUI(gd)
    plotmainaxes([],[],gd);
end

%% INDIVIDUAL ROIs
function AddROI(hObject, eventdata, gd)
if strcmp(gd.state.UIstate, 'ready')
    % Update State
    gd.state.UIstate='ROIadd'; % save current state
    % Update Index
    gd.Internal.ROIs.n = gd.Internal.ROIs.n + 1;
    gd.ROIs.rois(gd.Internal.ROIs.n).label = {}; % initialize to not be labeled
    gd.ROIs.rois(gd.Internal.ROIs.n).tag = '';
    gd.ROIs.rois(gd.Internal.ROIs.n).color = [];
    gd.ROIs.rois(gd.Internal.ROIs.n).depth = gd.state.currentDepth;
    gd.ROIs.rois(gd.Internal.ROIs.n).frame = gd.state.currentFrame;
    gd.ROIs.rois(gd.Internal.ROIs.n).rawdata = [];
    gd.ROIs.rois(gd.Internal.ROIs.n).rawneuropil = [];
    gd.ROIs.rois(gd.Internal.ROIs.n).mask = [];
    gd.ROIs.rois(gd.Internal.ROIs.n).neuropilmask = [];
    gd.ROIs.rois(gd.Internal.ROIs.n).pixels = [];
    gd.ROIs.rois(gd.Internal.ROIs.n).vertices = [];
    gd.ROIs.rois(gd.Internal.ROIs.n).position = [];
    gd.ROIs.rois(gd.Internal.ROIs.n).beingEdited = true;
    ROItypes = get(gd.ROI.type, 'String');
    switch ROItypes{get(gd.ROI.type, 'Value')}
        case 'ellipse'
            gd.ROIs.rois(gd.Internal.ROIs.n).type = 'ellipse';
            fcn = makeConstrainToRectFcn('imellipse',get(gca,'XLim'),get(gca,'YLim'));
        case 'polygon'
            gd.ROIs.rois(gd.Internal.ROIs.n).type = 'polygon';
            fcn = makeConstrainToRectFcn('impoly',get(gca,'XLim'),get(gca,'YLim'));
    end
    status = get([gd.View.frameSlider, gd.View.depthSlider], 'Enable');
    set([gd.ROI.color, gd.ROI.editAll, gd.ROI.deleteAll, gd.ROI.show, gd.ROI.showIDs, gd.ROI.add, gd.ROI.edit, gd.ROI.load, gd.View.frameSlider, gd.View.depthSlider, gd.View.playPause, gd.View.saveVideo], 'Enable', 'off');
    guidata(hObject,gd);
    
    % Place ROI
    switch ROItypes{get(gd.ROI.type, 'Value')}
        case 'ellipse'
            gd.ROIs.rois(gd.Internal.ROIs.n).handle = imellipse(gd.View.axes);
        case 'polygon'
            gd.ROIs.rois(gd.Internal.ROIs.n).handle = impoly(gd.View.axes);
    end
    setPositionConstraintFcn(gd.ROIs.rois(gd.Internal.ROIs.n).handle, fcn); % constrain ROI to within axes

    % Update guidata
    set([gd.ROI.color, gd.ROI.show, gd.ROI.showIDs, gd.View.playPause, gd.View.saveVideo, gd.ROI.add, gd.ROI.load], 'Enable', 'on');
    set(gd.View.frameSlider, 'Enable', status{1});
    set(gd.View.depthSlider, 'Enable', status{2});
    gd.state.UIstate='ROIedit';
    guidata(hObject, gd);
    updateGUI(gd)
end

function gd = EditROI(hObject, eventdata, gd)
if ~all([gd.ROIs.rois(:).beingEdited]) && get(gd.ROI.show, 'Value'); % make sure ROI(s) available
    % Determine ROI to Edit
    if isempty(eventdata) || ~isnumeric(eventdata)
        axes(gd.View.axes); % select main axes
        [x,y] = ginput(1); % user selects location on main axes (SLOW w/ a lot of objects on axes)
        % Find Closest ROI to ginput (COULD BE ACCOMPLISHED QUICKER)
%         centers = reshape([gd.ROIs.rois(:).centroid], 2, gd.Internal.ROIs.n)';
%         dist = pdist2([x,y],centers);
%         [~, closestROI] = min(dist);
        mindistance = sqrt(max(get(gca,'XLim'))^2+max(get(gca,'YLim')).^2);
        closestROI = [];
        for currentroi = 1:gd.Internal.ROIs.n
            if ~gd.ROIs.rois(currentroi).beingEdited && (~get(gd.ROI.showDepth, 'Value') || gd.ROIs.rois(currentroi).depth==gd.state.currentDepth)
                distance = squareform(pdist([x,y;gd.ROIs.rois(currentroi).vertices]));
                current_mindistance = min(distance(1,2:end));
                if current_mindistance < mindistance
                    mindistance = current_mindistance;
                    closestROI = currentroi;
                end
            end
        end
        if isempty(closestROI) %no extra ROIs exist on current depth
            return
        end
    else
        closestROI = eventdata;
    end
    % Update State
    gd.state.UIstate='ROIedit'; % save current state
    guidata(hObject,gd);
    gd.ROIs.rois(closestROI).beingEdited = true;
    % Update GUI
    updateGUI(gd)
    % Update Plot
    plotmainaxes([],[],gd); % Display current image without selected ROI
end

function SaveROI(hObject,eventdata,gd)
if strcmp(gd.state.UIstate, 'ROIedit')
    editIndex = find([gd.ROIs.rois(:).beingEdited]);
    if ~isempty(editIndex)
        for rindex = editIndex
            if ~isvalid(gd.ROIs.rois(rindex).handle)
                errordlg('Place ROI first');
            else
                % Save ROI Information
                switch gd.ROIs.rois(rindex).type
                    case 'ellipse'
                        gd.ROIs.rois(rindex).vertices = getVertices(gd.ROIs.rois(rindex).handle);
                        gd.ROIs.rois(rindex).position = getPosition(gd.ROIs.rois(rindex).handle);
                    case 'polygon'
                        gd.ROIs.rois(rindex).vertices = getPosition(gd.ROIs.rois(rindex).handle);
                        gd.ROIs.rois(rindex).vertices = [gd.ROIs.rois(rindex).vertices;gd.ROIs.rois(rindex).vertices(1,:)];
                        gd.ROIs.rois(rindex).position = [];
                end
                gd.ROIs.rois(rindex).pixels = createMask(gd.ROIs.rois(rindex).handle);
                temp = regionprops(gd.ROIs.rois(rindex).pixels, 'centroid');
                gd.ROIs.rois(rindex).centroid = temp.Centroid;
                delete(gd.ROIs.rois(rindex).handle); % delete UI ROI
                % Assume ROI moved and remove extracted data
                gd.ROIs.rois(rindex).rawdata = [];
                gd.ROIs.rois(rindex).rawneuropil = [];
                gd.ROIs.rois(rindex).neuropilmask = [];
                gd.ROIs.rois(rindex).mask = [];
                % Update state
                gd.ROIs.rois(rindex).beingEdited = false;
                % Update tag
                if isempty(gd.ROIs.rois(rindex).tag);
                    gd.Internal.ROIs.tagIndex = gd.Internal.ROIs.tagIndex + 1;
                    gd.ROIs.rois(rindex).tag = num2str(gd.Internal.ROIs.tagIndex);
                end
            end
        end
        gd.ROIs.totalmask = [];
        gd.ROIs.totalneuropilmask = [];
        % Update GUI
        gd.state.UIstate='ready'; % reset current state to base state
        guidata(hObject, gd);
        updateGUI(gd)
        % Update Plot
        plotmainaxes([],[],gd); % Display Figure with new ROI
    end
end

function DeleteROI(hObject, eventData, gd)
if strcmp(gd.state.UIstate, 'ROIedit')
    editIndex = find([gd.ROIs.rois(:).beingEdited]);
    if ~isempty(editIndex)
        for rindex = editIndex
            delete(gd.ROIs.rois(rindex).handle); % delete UI adjustable ROI
        end
        % Remove ROI
        gd.ROIs.rois(editIndex) = [];
        gd.Internal.ROIs.n = gd.Internal.ROIs.n - numel(editIndex);
        % Reset masks
        gd.ROIs.totalmask = [];
        gd.ROIs.totalneuropilmask = [];
        % Update GUI
        gd.state.UIstate='ready'; % reset current state to base state
        guidata(hObject, gd);
        updateGUI(gd);
        plotmainaxes([],[],gd);
    end
end

%% Current ROI
function ROIcurrentLabels(hObject,eventdata,gd)

function ROIcurrentTag(hObject,eventdata,gd)
if gd.Internal.ROIs.current
    gd.ROIs.rois(gd.Internal.ROIs.current).tag = get(hObject, 'String');
    guidata(hObject, gd);
end

%% DISPLAYING ROIs
function replotaxes(~,~,gd)
plotmainaxes([],[],gd);

%% Exporting Data
function ExportData(hObject,eventdata,gd)

% Determine selection and variable to export
contents = get(gd.ExportData.selection, 'String');
selection = contents{get(gd.ExportData.selection, 'Value')};
switch selection
    case 'Image Filename'
        basename = 'ImageFiles';
        var = gd.Images.filenames;
    case 'Images'
        basename = 'Images';
        var = gd.Images;
    case 'loadObj'
        basename = 'loadObj';
        var = gd.Images.info;
    case 'Experiment Filename'
        basename = 'ExperimentFile';
        var = gd.Experiment.filename;
    case 'Experiment'
        basename = 'Experiment';
        var = gd.Experiment;
    case 'ROIs Filename'
        basename = 'ROIFile';
        var = gd.ROIs.filename;
    case 'ROIdata'
        basename = 'ROIdata';
        var = gd.ROIs;
end

% Determine variable name as to not overwrite another variable
index = 0;
varname = basename;
while evalin('base',sprintf('exist(''%s'',''var'')',varname))
    index = index + 1;
    varname = strcat(basename, num2str(index));
end

% Export variable
assignin('base',varname,var);
fprintf('Exported %s to base workspace as: ''%s''\n', selection, varname);

%% Send information to holostim
function sendToHolostim(hObject,eventdata,gd)

if gd.Internal.ROIs.n>0;
    
    guidata(hObject, gd);
    set(gcf, 'pointer', 'watch')
 %   gd = CreateROIMasks(gd);
%    gd = CreateROINeuropilMasks(gd);
    ROIdata=gd.ROIs; % pull out ROI information
%    ROIdata.rois = rmfield(ROIdata.rois, {'handle','beingEdited'}); % remove fields used for editing ROIs
    
    
    
    VariablesToSave = {'ROIdata'};
    if gd.state.dataAvailable
        ImagesInfo = gd.Images.info;
        VariablesToSave = [VariablesToSave,{'ImagesInfo'}];
    end
    
    drawnow
    
    
    % ARM - Depricated when we switched to optotune 3D alignment]
    
    %if gd.Holo.centerStack == 1;
    %    k=(ImagesInfo.Depth*ImagesInfo.ZStepSize);
    %    ZVector=[(-k/2):ImagesInfo.ZStepSize:(k/2)];
    %else
    %    ZVector=[0:ImagesInfo.ZStepSize:ImagesInfo.Depth*ImagesInfo.ZStepSize];
    %end;
    %ImagesInfo.ZVector = ZVector;
    
    
    %tack the sutter value onto each ROI
    %for n =1:numel(ROIdata.rois);
    %    ROIdata.rois(n).Zlevel = ZVector(ROIdata.rois(n).depth);
    %end;
    %ROIdata=segmentImages(ROIdata,gd);
    
    %save variablestosave to holorequest listener folder and the copy
    %folder that the DAQ listens to
    
    %Replacment for Z / optotune - ARM 1/6/17
    
    
    
    meta = ScanImageTiffReader(ImagesInfo.files.FullFilename).metadata();
    SI = parseSI5Header(meta);

    OptotuneDepths = SI.SI.hStackManager.zs;
    zoomFactor = SI.SI.hRoiManager.scanZoomFactor;
    
    
    for j=1:numel(ROIdata.rois);
        ROIdata.rois(j).OptotuneDepth=OptotuneDepths(ROIdata.rois(j).depth);
    end
    
    %remove erroneous info from ImagesInfo and include the metadata for
    %future downstream use
    ImagesInfo=rmfield(ImagesInfo,'FrameRate');
    ImagesInfo=rmfield(ImagesInfo,'ZStepSize');
    ImagesInfo.MetData=SI;
    ImagesInfo.OptotuneDepths= OptotuneDepths;
    ImagesInfo.zoomFactor=zoomFactor;

    locations = FrankenScopeRigFile();
    save([locations.HoloRequest 'ROIdata.mat'],VariablesToSave{:},'-mat')
    save([locations.HoloRequest_DAQ 'ROIdata.mat'],VariablesToSave{:},'-mat')
    set(gcf, 'pointer', 'arrow')
    
    
    HoloInterface3
    
else
    errordlg('select at least one ROI, genius')
end;



function centerStack(hObject,eventdata,gd)
if (get(hObject,'Value') == get(hObject,'Max'))
	gd.Holo.centerStack=1;
else
	gd.Holo.centerStack=0;
end

guidata(hObject,gd);

function dispTargetArea(hObject,eventdata,gd)
if (get(hObject,'Value') == get(hObject,'Max'))
	gd.Holo.dispTarget=1;
    %get list of depths
    %convert to rectangle
    if ~isfield(gd.Holo,'optotuneDepths') ||...
            ~isfield(gd.Holo,'targetRect') ||...
            gd.Holo.recalcTargetArea ==1
        
        meta = ScanImageTiffReader(gd.Images.info.files.FullFilename).metadata();
        SI = parseSI5Header(meta);
        gd.Holo.optotuneDepths = SI.SI.hStackManager.zs;
        
        gd.Holo.zoom = SI.SI.hRoiManager.scanZoomFactor;
        
        try
        gd.Holo.targetRect = plotBoundingBox(gd.Holo.optotuneDepths,gd.Holo.zoom);
        catch
            errordlg({'Error in Display Target Area (ROIanalysis)', 'Could not plot bounding box.', ['Detected Depths: ' ...
                num2str(gd.Holo.optotuneDepths) '.'], ['Detected Zoom: ' num2str(gd.Holo.zoom)]})
        end
        
        gd.Holo.recalcTargetArea =0;
    end
    
    
    plotmainaxes([],[],gd);
else
	gd.Holo.dispTarget=0;
    plotmainaxes([],[],gd);
end

guidata(hObject,gd);

function ExtractROIs(hObject,eventdata,gd)
    

avgImg=gd.Images.Computations.Data.Average; 
meta = ScanImageTiffReader(gd.Images.info.files.FullFilename).metadata();
SI = parseSI5Header(meta);
   
newOptotuneDepths= SI.SI.hStackManager.zs;
newZoom= SI.SI.hRoiManager.scanZoomFactor;

DataOut=extractROIs(avgImg,newOptotuneDepths) ;  

nroi=numel(gd.ROIs.rois);
zimg=zeros(512,512);
for j = 1:numel(newOptotuneDepths);
    stats=DataOut(j).OC;
    
    for a = 1:size(stats,1);
    nroi=nroi+1;  
    
    gd.ROIs.rois(nroi).label={};   
    gd.ROIs.rois(nroi).color=[];
    gd.ROIs.rois(nroi).depth=(j); 
    gd.ROIs.rois(nroi).frame=1;
    gd.ROIs.rois(nroi).rawdata=[];
    gd.ROIs.rois(nroi).rawneuropil=[];
    gd.ROIs.rois(nroi).mask=[];
    gd.ROIs.rois(nroi).tag=1;
    gd.ROIs.rois(nroi).neuropilmask=1;
    gd.ROIs.rois(nroi).pixels=[];
    gd.ROIs.rois(nroi).position=[];
    gd.ROIs.rois(nroi).beingEdited=0;
    gd.ROIs.rois(nroi).type='ellipse';
   %! gd.ROIs.rois(nrois).handle=[1x1 imellipse];
    gd.ROIs.rois(nroi).centroid=stats(a,1:2);

    r=6; %6 um radius
    x=    gd.ROIs.rois(nroi).centroid(1);
    y=    gd.ROIs.rois(nroi).centroid(2);
    th = 0:pi/10:2*pi;
    xunit = r * cos(th) + x;
    yunit = r * sin(th) + y;
    gd.ROIs.rois(nroi).vertices(:,1)=xunit;
    gd.ROIs.rois(nroi).vertices(:,2)=yunit;
    
    end

end    

gd.Internal.ROIs.n=nroi;
plotmainaxes([],[],gd)
guidata(hObject,gd);
    